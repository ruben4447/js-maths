/*! For license information please see script.js.LICENSE.txt */
(()=>{var e={365:e=>{const t={GENERAL:"ERGEN",BAD_ARG:"ERARG",ARG_COUNT:"EARGN",BAD_IMPORT:"EIMPT",PROP:"EPROP",SYNTAX:"ESYTX",UNMATCHED_BRACKET:"EBRKT",UNTERM_STRING:"ESTR",NAME:"ENAME",NULL_REF:"ENREF",NOT_CALLABLE:"ECALL",CANT_COPY:"ECOPY",ASSIGN:"EASGN",DEL:"ERDEL",TYPE_ERROR:"ETYPE",CAST_ERROR:"ECAST",JSON_ERROR:"EJSON"},r={[t.GENERAL]:"An error has occured which relates to no specific code",[t.BAD_ARG]:"A bad or malformed argument was passed to a function, procedure or operator",[t.ARG_COUNT]:"An invalid number of arguments was passed to function, procedure or operator",[t.BAD_IMPORT]:"Error whilst importing a script via import()",[t.PROP]:"Error accessing a property of an object",[t.SYNTAX]:"A general syntax error (more information in error message)",[t.UNTERM_STRING]:"A string literal was not terminated when End Of Input was reached",[t.UNMATCHED_BRACKET]:"Found an unmatching/unexpected bracket",[t.NAME]:"A name (variable/function) cannot be found",[t.NULL_REF]:"Encountered a reference pointing to a null object (does not exist)",[t.NOT_CALLABLE]:"Attempted to call a non-callable object",[t.CANT_COPY]:"Error whilst copying a given object",[t.ASSIGN]:"Error whilst assigning to a given object",[t.DEL]:"Error whilst attempting to delete (remove) an object",[t.TYPE_ERROR]:"One or more types is invalid, unexpected or incorrect for the given context",[t.CAST_ERROR]:"Unable to cast the given value to the given type",[t.JSON_ERROR]:"Malformed JSON"};e.exports={errors:t,errorDesc:r}},317:(e,t,r)=>{const{UndefinedValue:n}=r(444),{createEvalObj:i,propagateEvalObj:s}=r(89),{errors:o}=r(365);var a=0;class l{constructor(e,t,r,n,i){this.id=a++,this.rs=e,this.pid=n,e.get_process(n).blocks.set(this.id,this),this.tokenLines=t,this.pos=r,this.parent=i,this.labels=new Map,this.breakable=this.parent?.breakable?1:0,this.returnable=this.parent?.returnable?1:0}prepare(){this.tokenLines.forEach((e=>{e.block=this,e.prepare()}))}async preeval(e){for(let t=0;t<this.tokenLines.length;t++){let r=this.createEvalObj(t);if(r.pid=e.pid,await this.tokenLines[t].preeval(r),0!==r.action){if(4!==r.action){s(r,e);break}this.bindLabel(r.actionValue,this.id,t),r=this.createEvalObj(t),r.pid=e.pid}}}async eval(e,t=0){let r,i=this.rs.get_process(this.pid);for(let n=t;n<this.tokenLines.length;n++){let t=this.createEvalObj(n);if(t.pid=e.pid,r=await this.tokenLines[n].eval(t),3===i.state){e.action=-1,e.actionValue=i.stateValue;break}if(2===i.state){e.action=-1;break}if(0!==t.action)if(1===t.action){if(1===this.breakable){e.action=1;break}}else if(2===t.action&&this.breakable){if(this.breakable){e.action=2;break}}else{if(3!==t.action){if(5===t.action){const i=this.seekLabel(t.actionValue);if(void 0===i)throw new Error(`[${o.NAME}] Name Error: unbound label '${t.actionValue}'`);const[s,a]=i,l=this.rs.get_process(this.pid).blocks.get(s);if(!l)throw new Error(`FATAL: block with ID ${s} does not exist (label '${t.actionValue}')`);t=this.createEvalObj(n),t.pid=e.pid,r=await l.eval(t,a+1),e.action=-2;break}s(t,e);break}if(this.returnable>0){1===this.returnable&&(e.action=3),e.actionValue=t.actionValue,r=t.actionValue;break}}}return r??new n(this.rs)}createEvalObj(e){return i(this.id,e,this.pid)}createChild(e,t){return new l(this.rs,e,t,this.pid,this)}bindLabel(e,t,r){this.labels.set(e,[t,r]),this.parent&&this.parent.bindLabel(e,t,r)}seekLabel(e){return this.labels.has(e)?this.labels.get(e):this.parent?this.parent.seekLabel(e):void 0}getAllLabels(e){return e=void 0===e?new Map(this.labels):new Map([...this.labels,...e]),this.parent&&this.parent.getAllLabels(e),e}}e.exports={Block:l}},39:(e,t,r)=>{const{errors:n}=r(365),{sortObjectByLongestKey:i}=r(89),{UndefinedValue:s,StringValue:o}=r(444),a={".":{name:"member access",precedence:20,args:2,fn:(e,t)=>{if("function"!=typeof t.getVar)throw new Error(`[${n.PROP}] Key Error: type ${t.type()} is not a valid key`);if(!(e=e.castTo("any")).__get__)throw new Error(`[${n.PROP}] Key Error: Cannot access property ${t.value} of type ${e.type()}`);return e.__get__(new o(e.rs,t.value))},desc:"Access property <prop> of <obj>",syntax:"<obj>.<prop>",assoc:"ltr"},"[]":{name:"computed member access",precedence:20,args:1,fn:async(e,t,r)=>{if(e=e.castTo("any"),t=await t.eval(r),!e.__get__)throw new Error(`[${n.PROP}] Key Error: Cannot access property ${t} of type ${e.type()}`);return e.__get__(t)},desc:"Evaluate <prop> and access property <prop> of <obj>",syntax:"<obj>[<prop>]",assoc:"ltr",hidden:!0},"()":{name:"call",precedence:20,args:1,fn:async(e,t,r)=>{if(!(e=e.castTo("any")).__call__)throw new Error(`[${n.NOT_CALLABLE}] Type Error: Type ${e.type()} is not callable ("${e}")`);let i=[];for(let e=0;e<t.length;e++){let s=!1;"..."===t[e].tokens[0]?.value&&(s=t[e].tokens[0],t[e].tokens.splice(0,1));let o=await t[e].eval(r);if(s){let e;try{e=o.toPrimitive("array")}catch{throw new Error(`[${n.TYPE_ERROR}] Type Error: '...': cannot expand type ${o.type()} at position ${s.pos+4}`)}i.push(...e)}else i.push(o)}return await e.__call__(r,i)},desc:"calls function with given arguments",syntax:"<func>(<args>)",assoc:"ltr",hidden:!0},"?.":{name:"oprional member access",precedence:20,args:2,fn:(e,t)=>{if((e=e.castTo("any"))instanceof s)return new s(e.rs);if(!e.__get__)throw new Error(`[${n.PROP}] Key Error: Cannot access property ${t} of type ${e.type()}`);return e.__get__(t.castTo("any"))},desc:"Access property <prop> of <obj>",syntax:"<obj>.<prop>",assoc:"ltr"},deg:{name:"degrees",precedence:18,args:1,fn:e=>e.castTo("any").__deg__?.(),desc:"Take argument as degrees and convert to radians",syntax:"<a>deg",assoc:"rtl"},"!":{name:"logical not",precedence:17,args:1,fn:e=>e.castTo("any").__not__?.(),desc:"logical not unless x is of type set. Then, find complement of x (using universal set, ε)",syntax:"x!",assoc:"rtl"},"~":{name:"bitwise not",precedence:17,args:1,fn:e=>e.castTo("any").__bitwiseNot__?.(),desc:"Bitwise NOT",syntax:"~x",assoc:"rtl"},"u+":{name:"unary plus",precedence:17,args:1,fn:e=>e.castTo("any").__pos__?.(),desc:"cast n into a number",syntax:"+n",unary:"u+",assoc:"rtl"},"u-":{name:"unary minus",precedence:17,args:1,fn:e=>e.castTo("any").__neg__?.(),desc:"cast n into a negative number",syntax:"-n",unary:"u-",assoc:"rtl"},"<cast>":{name:"cast",precedence:17,args:1,fn:(e,t)=>e.castTo(t),desc:"attempt to cast <val> to type <type>",syntax:"<type> value",unary:"<cast>",assoc:"rtl",hidden:!0},"?":{name:"boolean cast",precedence:17,args:1,fn:e=>e.castTo("bool"),desc:"attempt to cast <val> to a boolean",syntax:"value?",unary:"?",assoc:"ltr"},"**":{name:"exponentation",precedence:16,args:2,fn:(e,t)=>e.castTo("any").__pow__?.(t.castTo("any")),desc:"exponentation: raise a to the b",syntax:"a ** b",assoc:"rtl"},":":{name:"sequence",precedence:16,args:2,fn:(e,t)=>e.castTo("any").__seq__?.(t.castTo("any")),desc:"generates sequence a to b",syntax:"a:b",assoc:"rtl"},"/":{name:"division",precedence:15,args:2,fn:(e,t)=>e.castTo("any").__div__?.(t.castTo("any")),desc:"a ÷ b",syntax:"a / b",assoc:"ltr"},"%":{name:"modulo",precedence:15,args:2,fn:(e,t)=>e.castTo("any").__mod__?.(t.castTo("any")),desc:"a % b (remainder of a ÷ b)",syntax:"a % b",assoc:"ltr"},"*":{name:"multiplication",precedence:15,args:2,fn:(e,t)=>e.castTo("any").__mul__?.(t.castTo("any")),desc:"a × b",syntax:"a * b",assoc:"ltr"},"+":{name:"addition",precedence:14,args:2,fn:(e,t)=>e.castTo("any").__add__?.(t.castTo("any")),desc:"a + b",syntax:"a + b",unary:"u+",assoc:"ltr"},"-":{name:"subtract",precedence:14,args:2,fn:(e,t)=>e.castTo("any").__sub__?.(t.castTo("any")),desc:"a - b",syntax:"a - b",unary:"u-",assoc:"ltr"},"<<":{name:"right shift",precedence:13,args:2,fn:(e,t)=>e.castTo("any").__lshift__?.(t.castTo("any")),desc:"Bitwise left shift a by b places",syntax:"a << b",assoc:"ltr"},">>":{name:"left shift",precedence:13,args:2,fn:(e,t)=>e.castTo("any").__rshift__?.(t.castTo("any")),desc:"Bitwise right shift a by b places",syntax:"a >> b",assoc:"ltr"},"<=":{name:"less than or equal to",precedence:12,args:2,fn:(e,t)=>e.castTo("any").__le__?.(t.castTo("any")),desc:"a less than or equal to b",syntax:"a <= b",assoc:"ltr"},"<":{name:"less than",precedence:12,args:2,fn:(e,t)=>e.castTo("any").__lt__?.(t.castTo("any")),desc:"a less than b",syntax:"a < b",assoc:"ltr"},">=":{name:"greater than or equal to",precedence:12,args:2,fn:(e,t)=>e.castTo("any").__ge__?.(t.castTo("any")),desc:"a greater than or equal to b",syntax:"a >= b",assoc:"ltr"},">":{name:"greater than",precedence:12,args:2,fn:(e,t)=>e.castTo("any").__gt__?.(t.castTo("any")),desc:"a greater than b",syntax:"a > b",assoc:"ltr"},"in ":{name:"in",precedence:12,args:2,fn:(e,t)=>e.castTo("any").__in__?.(t.castTo("any")),desc:"check if <a> is in <b>. (NB a space after 'in' is required)",syntax:"a in b",assoc:"rtl"},"==":{name:"equality",precedence:11,args:2,fn:(e,t)=>e.castTo("any").__eq__?.(t.castTo("any")),desc:"a equal to b",syntax:"a == b",assoc:"ltr"},"!=":{name:"inequality",precedence:11,args:2,fn:(e,t)=>e.castTo("any").__neq__?.(t.castTo("any")),desc:"a not equal to b",syntax:"a != b",assoc:"ltr"},"&":{name:"bitwise and",precedence:10,args:2,fn:(e,t)=>e.castTo("any").__bitwiseAnd__?.(t.castTo("any")),desc:"Bitwise AND",syntax:"a & b",assoc:"ltr"},"^":{name:"bitwise xor",precedence:9,args:2,fn:(e,t)=>e.castTo("any").__xor__?.(t.castTo("any")),desc:"Bitwise XOR",syntax:"a ^ b",assoc:"ltr"},"|":{name:"bitwise or",precedence:8,args:2,fn:(e,t)=>e.castTo("any").__bitwiseOr__?.(t.castTo("any")),desc:"Bitwise OR",syntax:"a | b",assoc:"ltr"},"&&":{name:"logical and",precedence:7,args:2,fn:(e,t)=>e.castTo("any").__and__?.(t.castTo("any")),desc:"Logical AND",syntax:"a && b",assoc:"ltr"},"||":{name:"logical or",precedence:6,args:2,fn:(e,t)=>e.castTo("any").__or__?.(t.castTo("any")),desc:"Logical OR",syntax:"a || b",assoc:"ltr"},"??":{name:"nullish coalescing",precedence:5,args:2,fn:(e,t)=>e.castTo("any")instanceof s?t:e,desc:"Returns <a> unless it is undefined, in which case return <b>",syntax:"a ?? b",assoc:"ltr"},"?:":{name:"conditional",precedence:4,args:0,fn:async([e,t,r],n)=>{let i=await e.eval(n);return i=i.castTo("bool"),i.value?await t.eval(n):r?await r.eval(n):i},desc:"Returns <b> if <a> is truthy, else <c> (or false)",syntax:"(<a>) ? (<b>) [: <c>]",assoc:"rtl",hidden:!0},"=":{name:"assignment",precedence:3,args:2,fn:(e,t)=>e.__assign__?.(t.castTo("any")),desc:"Set symbol <symbol> equal to <v>",syntax:"symbol = v",assoc:"rtl"},"=>":{name:"nonlocal assignment",precedence:3,args:2,fn:(e,t)=>e.__nonlocalAssign__?.(t.castTo("any")),desc:"Set symbol <symbol> in nonlocal scope equal to <v>",syntax:"symbol => v",assoc:"rtl"},"+=":{name:"addition assignment",precedence:3,args:2,fn:(e,t)=>e.__assignAdd__?.(t),desc:"Add <v> to <symbol>",syntax:"symbol += v",assoc:"rtl"},"-=":{name:"subtraction assignment",precedence:3,args:2,fn:(e,t)=>e.__assignSub__?.(t),desc:"Subtract <v> from <symbol>",syntax:"symbol -= v",assoc:"rtl"},"*=":{name:"multiplication assignment",precedence:3,args:2,fn:(e,t)=>e.__assignMul__?.(t),desc:"Multiply <symbol> by <v>",syntax:"symbol *= v",assoc:"rtl"},"/=":{name:"division assignment",precedence:3,args:2,fn:(e,t)=>e.__assignDiv__?.(t),desc:"Divide <symbol> by <v>",syntax:"symbol /= v",assoc:"rtl"},"%=":{name:"modulus assignment",precedence:3,args:2,fn:(e,t)=>e.__assignMod__?.(t),desc:"Sets <symbol> to <symbol> % <v>",syntax:"symbol %= v",assoc:"rtl"},",":{name:"comma",precedence:1,args:2,fn:(e,t)=>t,desc:"Used to seperate statements. Evaluates <lhs> and <rhs>, but only returns <rhs>",syntax:"<statement>, <statement>",assoc:"ltr"}};e.exports=i(a)},296:(e,t,r)=>{const n=r(39),i={"[":"]","]":"[","(":")",")":"(","{":"}","}":"{"},s={"[":1,"]":-1,"(":1,")":-1,"{":1,"}":-1},o={x:16,d:10,b:2,o:8},a={16:/[0-9A-Fa-f]/,10:/[0-9]/,2:/[01]/,8:/[0-7]/};e.exports={bracketMap:i,bracketValues:s,getMatchingBracket:function(e,t){if(void 0===i[t[e]])throw new Error("Unexpected token '"+t[e]+"' at position "+e+": cannot match token");let r,n,o=0,a=e,l=s[t[e]];for(1===l?(r=t[e],n=i[r]):(n=t[e],r=i[n]);a>-1&&a<t.length;){if(t[a]==n?o--:t[a]==r&&o++,0==o)return a;a+=l}throw new Error("No matching bracket found for '"+t[e]+"' in position "+e)},parseOperator:function(e){for(let t in n)if(n.hasOwnProperty(t)&&!n[t].hidden&&t===e.substr(0,t.length))return t;return null},parseNumber:function e(t,r=!0,n="_",i="i"){let s=0,l=1,c="",u="",h=10,p=null,f=!1,d=!1,m=!1,w=!1,g=!1,v=!1;for(s=0;s<t.length;s++)if(f||"-"!==t[s]&&"+"!==t[s])if(0===s&&"0"===t[s]&&t[s+1]in o)s++,h=o[t[s]];else if(a[h].test(t[s]))g=!1,f||(f=!0),m?(u+=t[s],w=!0):(c+=t[s],d=!0);else if("."===t[s]){if(g)throw new Error("Invalid syntax: expected digit in number literal");if(m)break;m=!0}else{if("e"===t[s].toLowerCase()){if(g)throw new Error("Invalid syntax: expected digit in number literal");if(g=!1,r){const r=e(t.substr(s+1),!1,n,!1);if(""===r.str)break;s+=1+r.pos,p=r;break}break}if(t[s]!==n)break;if(g)throw new Error("Invalid number literal: unexpected seperator");if(m&&!w)break;if(!d)break;g=!0}else f=!0,l="-"===t[s]?-1:1,g=!1;!i||""===c&&""===u||t[s]!==i||(s++,v=!0),""!==c&&(c=parseInt(c,h)),""!==u&&(u=parseInt(u,h));let _=c+(m?"."+u:"");("."===_||_.startsWith(".e"))&&(s=0,_="");let y=l*+_,b=y;return p&&(y*=Math.pow(10,p.num),_+="e"+p.str,p=p.num),v&&(_+=i),{pos:s,str:t.substring(0,s),sign:l,base:b,exp:p,radix:h,num:y,imag:v}},parseSymbol:function(e){const t=/[A-Za-z_$]/,r=/[0-9]/;if(!t.test(e[0]))return null;let n=e[0];for(let i=1;i<e.length&&(t.test(e[i])||r.test(e[i]));i++)n+=e[i];return n}}},974:(e,t,r)=>{const{errors:n}=r(365),{RunspaceUserFunction:i}=r(225),{expectedSyntaxError:s,peek:o,createEvalObj:a,propagateEvalObj:l,equal:c}=r(89),{FunctionRefValue:u,ArrayValue:h,SetValue:p,MapValue:f}=r(444);class d{constructor(e,t,r){this.rs=e,this.name=t,this.pos=r}eval(e){throw new Error(`${this}.eval: overload required`)}validate(){throw new Error(`${this}.validate: overload required`)}toString(){return`<Structure ${this.name}>`}}e.exports={Structure:d,ArrayStructure:class extends d{constructor(e,t,r){super(e,"ARRAY",r),this.elements=t,this.assignment=!1}validate(){this.elements.forEach((e=>e.prepare()))}async eval(e){if(this.assignment){let e=[];for(let t=0;t<this.elements.length;t++){let r=this.elements[t];if(1!==r.tokens.length||"function"!=typeof r.tokens[0].getVarNoError)throw new Error(`[${n.SYNTAX}] Syntax Error: malformed array assignation expression. Expected array of symbols on lhs of expression at position ${this.pos}, member ${t}`);e.push(r.tokens[0])}return new h(this.rs,e,!1)}{let t=await Promise.all(this.elements.map((t=>t.eval(e))));return new h(this.rs,t)}}},SetStructure:class extends d{constructor(e,t,r){super(e,"SET",r),this.elements=t,this.assignment=!1}validate(){this.elements.forEach((e=>e.prepare()))}async eval(e){if(this.assignment){let e=[];for(let t=0;t<this.elements.length;t++){let r=this.elements[t];if(1!==r.tokens.length||"function"!=typeof r.tokens[0].getVarNoError)throw new Error(`[${n.SYNTAX}] Syntax Error: malformed map assignation expression. Expected set of symbols on lhs of expression at position ${this.pos}, member ${t}`);e.push(r.tokens[0])}return new p(this.rs,e)}{let t=await Promise.all(this.elements.map((t=>t.eval(e))));return new p(this.rs,t.map((e=>e.castTo("any"))))}}},MapStructure:class extends d{constructor(e,t){super(e,"MAP",t),this.keys=[],this.values=[]}addPair(e,t){this.keys.push(e),this.values.push(t)}validate(){if(this.keys.length!==this.values.length)throw new Error(`${this}: keys and values arrays must be equal lengths`);this.values.forEach((e=>e.prepare()))}async eval(e){let t=new f(this.rs);for(let r=0;r<this.keys.length;r++)t.__set__(this.keys[r],await this.values[r].eval(e));return t}},IfStructure:class extends d{constructor(e,t,r=[],n){super(e,"IF",t),this.conditionals=r,this.thenBlock=n}addBranch(e,t){this.conditionals.push([e,t])}addElse(e){this.thenBlock=e}validate(){for(const[e,t]of this.conditionals){if(0===e.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got )`);if(e.value.length>1)throw new s(")",o(e.value[0].tokens));e.prepare(),t.prepare()}this.thenBlock?.prepare()}async eval(e){let t,r=!1,n=this.rs.get_process(e.pid);for(const[i,s]of this.conditionals){if((await i.eval(e)).toPrimitive("bool")){r=!0,t=await s.eval(e);break}if(1!==n.state)return}!r&&this.thenBlock&&(t=await this.thenBlock.eval(e))}},SwitchStructure:class extends d{constructor(e,t,r,n=[],i){super(e,"SWITCH",t),this.query=r,this.cases=n,this.elseBlock=i}addCase(e,t){this.cases.push([e,t])}addElse(e){this.elseBlock=e}validate(){if(0===this.query.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got )`);if(this.query.value.length>1)throw new s(")",o(this.query.value[0].tokens));this.query.prepare();for(const[e,t]of this.cases){for(const t of e){if(0===t.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got )`);if(t.value.length>1)throw new s(")",o(t.value[0].tokens));t.prepare()}t.breakable=1,t.prepare()}this.elseBlock&&this.elseBlock.prepare()}async eval(e){let t,r=await this.query.eval(e),n=this.rs.get_process(e.pid),i=!1,s=a(e.blockID,e.lineID,e.pid);for(const[o,a]of this.cases)for(const u of o){let o=await u.eval(e);if(c(r,o)&&(t=await a.eval(s),i=!0),i||1===s.action||1!==n.state)break;if(2===s.action)s.action=0;else if(3===s.action){l(s,e);break}}return this.elseBlock&&!i&&(t=await this.elseBlock.eval(s)),t}},WhileStructure:class extends d{constructor(e,t,r,n,i){super(e,"WHILE",t),this.condition=r,this.body=n,this.thenBlock=i}validate(){if(0===this.condition.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got )`);if(this.condition.value.length>1)throw new s(")",o(this.condition.value[0].tokens));this.body.breakable=1,this.body.prepare(),this.condition.prepare(),this.thenBlock&&this.thenBlock.prepare()}async eval(e){let t=a(e.blockID,e.lineID,e.pid),r=this.rs.get_process(e.pid);for(;;){if(!(await this.condition.eval(t)).toPrimitive("bool")){this.thenBlock&&await this.thenBlock.eval(t),3===t.action&&l(t,e);break}if(await this.body.eval(t),1===t.action||1!==r.state)break;if(2===t.action)t.action=0;else if(3===t.action){l(t,e);break}}}},DoWhileStructure:class extends d{constructor(e,t,r,n,i){super(e,"DOWHILE",t),this.condition=r,this.body=n,this.thenBlock=i}validate(){if(0===this.condition.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got )`);if(this.condition.value.length>1)throw new s(")",o(this.condition.value[0].tokens));this.body.breakable=1,this.body.prepare(),this.condition.prepare(),this.thenBlock&&this.thenBlock.prepare()}async eval(e){let t=a(e.blockID,e.lineID,e.pid),r=this.rs.get_process(e.pid);for(;await this.body.eval(t),1!==t.action&&1===r.state;){if(2===t.action)t.action=0;else if(3===t.action){l(t,e);break}if(!(await this.condition.eval(t)).toPrimitive("bool")){this.thenBlock&&await this.thenBlock.eval(t),3===t.action&&l(t,e);break}}}},UntilStructure:class extends d{constructor(e,t,r,n,i){super(e,"UNTIL",t),this.condition=r,this.body=n,this.thenBlock=i}validate(){if(0===this.condition.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got )`);if(this.condition.value.length>1)throw new s(")",o(this.condition.value[0].tokens));this.body.breakable=1,this.body.prepare(),this.condition.prepare(),this.thenBlock&&this.thenBlock.prepare()}async eval(e){let t=a(e.blockID,e.lineID,e.pid),r=this.rs.get_process(e.pid);for(;;){if((await this.condition.eval(t)).toPrimitive("bool")){this.thenBlock&&await this.thenBlock.eval(t),3===t.action&&l(t,e);break}if(await this.body.eval(t),1===t.action||1!==r.state)break;if(2===t.action)t.action=0;else if(3===t.action){l(t,e);break}}}},DoUntilStructure:class extends d{constructor(e,t,r,n,i){super(e,"DOUNTIL",t),this.condition=r,this.body=n,this.thenBlock=i}validate(){if(0===this.condition.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got )`);if(this.condition.value.length>1)throw new s(")",o(this.condition.value[0].tokens));this.body.breakable=1,this.body.prepare(),this.condition.prepare(),this.thenBlock&&this.thenBlock.prepare()}async eval(e){let t=a(e.blockID,e.lineID,e.pid),r=this.rs.get_process(e.pid);for(;await this.body.eval(t),1!==t.action&&1===r.state;){if(2===t.action)t.action=0;else if(3===t.action){l(t,e);break}if((await this.condition.eval(t)).toPrimitive("bool")){this.thenBlock&&await this.thenBlock.eval(t),3===t.action&&l(t,e);break}}}},LoopStructure:class extends d{constructor(e,t,r){super(e,"LOOP",t),this.body=r}validate(){this.body.breakable=1,this.body.prepare()}async eval(e){const t=a(e.blockID,e.lineID,e.pid),r=this.rs.get_process(e.pid);for(;await this.body.eval(t),1!==t.action&&1===r.state;)if(2===t.action)t.action=0;else if(3===t.action){l(t,e);break}}},ForStructure:class extends d{constructor(e,t,r,n,i){super(e,"FOR",t),this.loop=r,this.body=n,this.thenBlock=i}validate(){if(0===this.loop.value.length)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got ) (FOR loop)`);if(this.loop.value.length<2)throw new Error(`[${n.SYNTAX}] Syntax Error: expression expected, got end of input (FOR loop)`);if(this.loop.value.length>3)throw new s(")",o(this.loop.value[2].tokens));this.loop.value.forEach((e=>e.prepare())),this.body.breakable=1,this.body.prepare(),this.thenBlock&&this.thenBlock.prepare()}async eval(e){let t=a(e.blockID,e.lineID,e.pid),r=this.rs.get_process(e.pid);if(await this.loop.value[0].eval(t),this.loop.value[1].tokens.length<=1)for(;await this.body.eval(t),1!==t.action&&1===r.state;){if(2===t.action)t.action=0;else if(3===t.action){l(t,e);break}await(this.loop.value[2]?.eval(t))}else for(;;){if(!(await this.loop.value[1].eval(t)).toPrimitive("bool")){this.thenBlock&&await this.thenBlock.eval(t),3===t.action&&l(t,e);break}if(await this.body.eval(t),1===t.action)break;if(2===t.action)t.action=0;else if(3===t.action){l(t,e);break}await(this.loop.value[2]?.eval(t))}}},ForInStructure:class extends d{constructor(e,t,r,n,i){super(e,"FORIN",t),this.vars=r,this.iter=n,this.body=i,this.thenBlock=void 0}validate(){this.iter.prepare(),this.body.breakable=1,this.body.prepare(),this.thenBlock&&this.thenBlock.prepare()}async eval(e){let t,r=a(e.blockID,e.lineID,e.pid),i=this.rs.get_process(e.pid);try{t=await this.iter.eval(r),t=t.castTo("any")}catch(e){throw new Error(`[${n.SYNTAX}] FOR IN loop: error whilst evaluating iterator:\n${e}`)}if("function"!=typeof t.__iter__)throw new Error(`[${n.TYPE_ERROR}] Type ${t.type()} is not iterable`);let s=t.__iter__();if(0===s.length);else if(Array.isArray(s[0]))if(1===this.vars.length){let t=0;for(;;){if(t>=s.length){this.thenBlock&&await this.thenBlock.eval(r),3===r.action&&l(r,e);break}if(this.body.rs.defineVar(this.vars[0].value,new h(this.body.rs,s[t]),void 0,e.pid),await this.body.eval(r),1===r.action||1!==i.state)break;if(2===r.action)r.action=0;else if(3===r.action){l(r,e);break}t++}}else{if(this.vars.length!==s[0].length)throw new Error(`[${n.SYNTAX}] Syntax Error: FOR-IN: variable count mismatch: got ${this.vars.length}, expected ${s[0].length} for type ${t.type()}`);let o=0;for(;;){if(o>=s.length){this.thenBlock&&await this.thenBlock.eval(r),3===r.action&&l(r,e);break}for(let t=0;t<this.vars.length;t++)this.body.rs.defineVar(this.vars[t].value,s[o][t],void 0,e.pid);if(await this.body.eval(r),1===r.action||1!==i.state)break;if(2===r.action)r.action=0;else if(3===r.action){l(r,e);break}o++}}else{if(1!==this.vars.length)throw new Error(`[${n.SYNTAX}] Syntax Error: FOR-IN: variable count mismatch: got ${this.vars.length}, expected 1 for type ${t.type()}`);let o=0;for(;;){if(o>=s.length){this.thenBlock&&await this.thenBlock.eval(r),3===r.action&&l(r,e);break}if(this.body.rs.defineVar(this.vars[0].value,s[o],void 0,e.pid),await this.body.eval(r),1===r.action||1!==i.state)break;if(2===r.action)r.action=0;else if(3===r.action){l(r,e);break}o++}}}},FuncStructure:class extends d{constructor(e,t,r,n,i){super(t,"FUNC",e),this.name=i,this.args=r??{},this.body=n,this.returnType="any"}validate(){this.body.breakable=0,this.body.returnable=2,this.body.prepare()}async eval(e){let t,r=new i(this.rs,this.name??"anonymous",this.args,this.body,void 0,this.returnType),n=new u(this.rs,r);return this.name?this.rs.defineVar(r.name,n,void 0,e.pid):(n.func=r,t=n),t}},BreakStructure:class extends d{constructor(e){super("BREAK",e)}validate(){}async eval(e){e.action=1}},ContinueStructure:class extends d{constructor(e){super("CONTINUE",e)}validate(){}async eval(e){e.action=2}},ReturnStructure:class extends d{constructor(e,t){super("RETURN",e),this.expr=t}validate(){this.expr.prepare()}async eval(e){let t=a(e.blockID,e.lineID,e.pid);e.action=3,e.actionValue=await this.expr.eval(t)}},LabelStructure:class extends d{constructor(e,t,r){super("LABEL",e),this.rs=t,this.label=r,this.bound=!1}validate(){}preeval(e){this.bound||(e.action=4,e.actionValue=this.label,this.bound=!0)}eval(e){}},GotoStructure:class extends d{constructor(e,t,r){super("GOTO",e),this.rs=t,this.label=r}validate(){}eval(e){e.action=5,e.actionValue=this.label}},LetStructure:class extends d{constructor(e,t,r){super("LET",e),this.rs=t,this.symbol=r,this.variation="single"}validate(){}async eval(e){switch(this.variation){case"array":for(let t=0;t<this.symbol.length;t++)this.rs.defineVar(this.symbol[t].value,void 0,void 0,e.pid);return new h(this.rs,this.symbol,!1);case"set":for(let t=0;t<this.symbol.length;t++)this.rs.defineVar(this.symbol[t].value,void 0,void 0,e.pid);return new p(this.rs,this.symbol);default:return this.rs.defineVar(this.symbol.value,void 0,void 0,e.pid),this.symbol}}}}},543:(e,t,r)=>{const{peek:n,str:i,createTokenStringParseObj:s,isWhitespace:o,throwMatchingBracketError:a,expectedSyntaxError:l,decodeEscapeSequence:c}=r(89),{bracketValues:u,bracketMap:h,parseNumber:p,parseOperator:f,parseSymbol:d}=r(296),{StringValue:m,NumberValue:w,Value:g,UndefinedValue:v,CharValue:_,BoolValue:y,FunctionRefValue:b}=r(444),k=r(39),{errors:E}=r(365),{IfStructure:x,Structure:$,WhileStructure:A,DoWhileStructure:T,ForStructure:S,DoUntilStructure:P,UntilStructure:N,FuncStructure:F,ArrayStructure:M,SetStructure:R,MapStructure:I,ForInStructure:O,LoopStructure:B,BreakStructure:C,ContinueStructure:V,ReturnStructure:D,SwitchStructure:L,LabelStructure:Y,GotoStructure:U,LetStructure:j}=r(974),{Block:z}=r(317),q=r(397),{RunspaceUserFunction:X}=r(225);class G{constructor(e,t,r=NaN){this.tstr=e,this.block=this.tstr.block,this.value=t,this.pos=r}setBlock(e){this.block=e}castTo(e){throw new Error(`Overload Required (type provided: ${e})`)}is(e,t){return this instanceof e&&null!=t&&this.value===t}toString(){return this.value.toString()}}class W extends G{constructor(e,t,r){super(e,t,r)}castTo(e){return this.value.castTo(e)}}class H extends G{constructor(e,t,r){super(e,t,r)}}H.keywords=["break","case","continue","do","else","false","for","func","goto","if","label","let","loop","return","switch","then","true","until","while"];class J extends G{constructor(e,t,r){if(super(e,t,r),void 0===k[t])throw new Error(`new OperatorToken() : '${t}' is not an operator`);this.isUnary=!1,this.data=void 0}async eval(e,t){let r,n=this.info().fn;if("function"!=typeof n)throw new Error(`[${E.ARG_COUNT}] Argument Error: no overload for operator function ${this.toString().trim()} with ${e.length} args`);try{r=await n(...e,this.data,t)}catch(t){throw new Error(`[${E.BAD_ARG}] Operator '${this.toString().trim()}' with { ${e.map((e=>e.type())).join(", ")} } at position ${this.pos}:\n${t}`)}if(r instanceof Error)throw r;if(void 0===r)throw new Error(`[${E.TYPE_ERROR}] Type Error: Operator ${this.toString().trim()} does not support arguments { ${e.map((e=>e.type())).join(", ")} } at position ${this.pos}`);return r}priority(){return+this.info().precedence}info(){let e=k[this.value];if(this.isUnary&&(e=k[e.unary],void 0===e))throw new Error(`[${E.ARG_COUNT}] Operator ${this.toString()} has no unary counterpart (isUnary=${this.isUnary})`);return e}toString(){return"<cast>"===this.value?"<"+this.data+">":this.isUnary?k[this.value].unary:this.value}}class K extends G{constructor(e,t,r){if(super(e,t,r),void 0===u[t])throw new Error(`new BracketToken() : '${t}' is not a bracket`);this.matching=void 0}priority(){return 0}facing(){return u[this.value]}}class Q extends G{constructor(e,t){super(e,Q.symbol,t)}toString(){return Q.symbol}}Q.symbol=";";class Z extends G{constructor(e,t){super(e,"...",t)}toString(){return"..."}}class ee extends G{constructor(e,t,r){super(e,t,r)}type(){let e=this.getVarNoError();return void 0===e?"symbol":"function"==typeof e.type?e.type():e.value.type()}castTo(e){let t=this.getVar();if(t.value===this)throw new Error(`Self-referencing variable (infinite lookup prevented) - variable '${this.value}'`);return t.castTo(e)}toPrimitive(e){return this.tstr.rs.getVar(this.value,this.tstr.block.pid).toPrimitive(e)}exists(){return void 0!==this.tstr.rs.getVar(this.value,this.tstr.block.pid)}getVar(){const e=this.tstr.rs.getVar(this.value,this.tstr.block.pid);return void 0===e&&this._throwNameError(),e}getVarNoError(){return this.tstr.rs.getVar(this.value,this.tstr.block.pid)}toString(){return i(this.getVar()?.value)}_throwNameError(){throw new Error(`[${E.NAME}] Name Error: name '${this.value}' does not exist (position ${this.pos})`)}__del__(){const e=this.tstr.rs.deleteVar(this.value,this.tstr.block.pid);return new y(this.tstr.rs,e)}__assign__(e){e=e.castTo("any");const t=this.value,r=this.getVarNoError();return r&&r.refFor?(r.refFor.value=e,r.value=e):this.tstr.rs.defineVar(t,e,void 0,this.tstr.block.pid),e}__nonlocalAssign__(e){e=e.castTo("any");const t=this.value;if(!this.exists())throw new Error(`[${E.NULL_REF}] Null Reference: no non-local binding for symbol '${t}'. Did you mean to use '=' ?`);return this.tstr.rs.setVar(t,e,void 0,this.tstr.block.pid),e}__assignAdd__(e){if(void 0!==(e=this.castTo("any").__add__(e.castTo("any"))))return this.tstr.rs.setVar(this.value,e,void 0,this.tstr.block.pid),e}__assignSub__(e){if(void 0!==(e=this.castTo("any").__sub__(e.castTo("any"))))return this.tstr.rs.setVar(this.value,e,void 0,this.tstr.block.pid),e}__assignMul__(e){if(void 0!==(e=this.castTo("any").__mul__(e.castTo("any"))))return this.tstr.rs.setVar(this.value,e,void 0,this.tstr.block.pid),e}__assignDiv__(e){if(void 0!==(e=this.castTo("any").__div__(e.castTo("any"))))return this.tstr.rs.setVar(this.value,e,void 0,this.tstr.block.pid),e}__assignMod__(e){if(void 0!==(e=this.castTo("any").__mod__(e.castTo("any"))))return this.tstr.rs.setVar(this.value,e,void 0,this.tstr.block.pid),e}}class te extends G{constructor(e,t,r,n){super(e,t,n),this.opening=r}setBlock(e){super.setBlock(e),this.value.forEach((t=>t.setBlock(e)))}prepare(e=!0){this.value.forEach((t=>{void 0!==t.block&&null===t.block&&(t.block=this.tstr.block),t.prepare(e)}))}async eval(e){let t;for(let r of this.value)t=await r.eval(e);return t??new v(this.tstr.rs)}toString(){return this.opening+this.value.toString()+h[this.opening]}toBlock(e){if(!this.tstr.block)throw new Error("BracketedTokenLines.toBlock :: this.tstr is not bound to a scope");return new z(this.tstr.rs,this.value,this.pos,e,this.tstr.block)}}class re{constructor(e,t,r=[],n=""){this.rs=e,this.block=t,this.source=n,this.tokens=void 0,this.comment="",this._ready=!1,this.updateTokens(r)}setBlock(e){this.block=e,this.tokens.forEach((t=>t.setBlock?.(e)))}updateTokens(e){this._ready=!1,this.tokens=[...e]}prepare(e=!0){this._ready||(this._ready=!0,this.setBlock(this.block),this.parse(),e&&(this.tokens=this.toRPN()))}splitByCommas(e=!0,t=!0){let r=[],n=!1,i=new re(this.rs,this.block),s=[];for(let e=0;e<this.tokens.length;e++)if(this.tokens[e]instanceof J&&","===this.tokens[e].value){if(!n)throw new Error(`[${E.SYNTAX}]: expected expression, got , at position ${this.tokens[e].pos}`);n=!1,i.updateTokens(s),r.push(i),i=new re(this.rs,this.block),s=[]}else s.push(this.tokens[e]),n=!0;return i&&0!==s&&(i.updateTokens(s),r.push(i)),e&&r.forEach((e=>e.prepare(t))),r}parse(){try{return this._parse()}catch(e){throw new Error(`${this.source}: \n${e} `)}}_parse(){for(let e=0;e<this.tokens.length;e++)if(this.tokens[e]instanceof W){if(this.tokens[e].value instanceof m){let t=this.tokens[e].value;for(let r in t.intpls)if(t.intpls.hasOwnProperty(r))try{t.intpls[r].val.setBlock(this.block),t.intpls[r].val.prepare()}catch(t){throw new Error(`[${E.GENERAL}] Error in interpolated string at ${this.tokens[e].pos} at string index ${r}:\n${t}`)}}this.tokens[e]=this.tokens[e].value}else if((this.tokens[e]instanceof ee||this.tokens[e]instanceof te&&"("===this.tokens[e].opening)&&this.tokens[e+1]instanceof J&&"-"===this.tokens[e+1].value&&this.tokens[e+2]instanceof J&&">"===this.tokens[e+2].value){let t=new F(this.tokens[e].pos,this.rs,{});if(t.args=this.tokens[e]instanceof ee?{[this.tokens[e].value]:{type:"any"}}:ie(this.tokens[e]),this.tokens[e+3]instanceof z)t.body=this.tokens[e+3],this.tokens.splice(e,4,t);else if(this.tokens[e+3]instanceof te&&"{"===this.tokens[e+3].opening)t.body=this.tokens[e+3].toBlock(this.block.pid),this.tokens.splice(e,4,t);else{let r=[],n=e+3;for(;n<this.tokens.length&&!(this.tokens[n]instanceof Q||this.tokens[n]instanceof J&&","===this.tokens[n].value);n++)r.push(this.tokens[n]);if(0===r.length)throw new Error(`[${E.SYNTAX}] Syntax Error: expression expected following '->', got ${this.tokens[n]?`${this.tokens[n]} at position ${this.tokens[n].pos}`:`end of input at position ${this.tokens[n-1].pos}`}`);t.body=this.block.createChild([new re(this.rs,void 0,r)],this.tokens[e+5]?.pos),this.tokens.splice(e,n-e,t)}t.validate()}else if((this.tokens[e]instanceof ee||this.tokens[e]instanceof te&&"("===this.tokens[e].opening)&&this.tokens[e+1]instanceof J&&":"===this.tokens[e+1].value&&this.tokens[e+3]instanceof J&&"-"===this.tokens[e+3].value&&this.tokens[e+4]instanceof J&&">"===this.tokens[e+4].value){let t=new F(this.tokens[e].pos,this.rs,{});if(t.returnType=this.tokens[e+2].value,t.args=this.tokens[e]instanceof ee?{[this.tokens[e].value]:{type:"any"}}:ie(this.tokens[e]),this.tokens[e+5]instanceof z)t.body=this.tokens[e+5],this.tokens.splice(e,6,t);else if(this.tokens[e+5]instanceof te&&"{"===this.tokens[e+3].opening)t.body=this.tokens[e+3].toBlock(this.block.pid),this.tokens.splice(e,6,t);else{let r=[],n=e+5;for(;n<this.tokens.length&&!(this.tokens[n]instanceof Q||this.tokens[n]instanceof J&&","===this.tokens[n].value);n++)r.push(this.tokens[n]);if(0===r.length)throw new Error(`[${E.SYNTAX}] Syntax Error: expression expected following '->', got ${this.tokens[n]?`${this.tokens[n]} at position ${this.tokens[n].pos}`:`end of input at position ${this.tokens[n-1].pos}`}`);t.body=this.block.createChild([new re(this.rs,void 0,r)],this.tokens[e+5]?.pos),this.tokens.splice(e,n-e,t)}t.validate()}else if(this.tokens[e]instanceof te){let t=!0;if("["===this.tokens[e].opening){if(0===e||this.tokens[e-1]instanceof Z||this.tokens[e-1]instanceof J&&"[]"!==this.tokens[e-1].value||this.tokens[e-1]instanceof K){let t;if(0===this.tokens[e].value.length)t=[];else{if(1!==this.tokens[e].value.length)throw new l("]",n(this.tokens[e].value[0].tokens));t=this.tokens[e].value[0].splitByCommas()}let r=new M(this.rs,t,this.tokens[e].pos);r.validate(),this.tokens[e]=r}}else if("("===this.tokens[e].opening){if(this.tokens[e+1]instanceof J&&"?"==this.tokens[e+1].value&&this.tokens[e+2]instanceof te&&"("===this.tokens[e+2].opening){let t=new J(this,"?:",this.tokens[e+1].pos),r=3;if(t.data=[this.tokens[e],this.tokens[e+2]],this.tokens[e+3]instanceof J&&":"===this.tokens[e+3].value){if(!(this.tokens[e+4]instanceof te&&"("===this.tokens[e+4].opening))throw new Error(`[${E.SYNTAX}] Syntax Error: expected (...) following ':' (position ${this.tokens[e+3].pos}) in conditional operator '?' (position ${this.tokens[e+1].pos}), got ${this.tokens[e+4]?.pos??"end of line"}`);t.data.push(this.tokens[e+4]),r+=2}for(let e of t.data)e.prepare();this.tokens.splice(e,r,t)}else if(0===e||this.tokens[e-1]instanceof Z||this.tokens[e-1]instanceof J&&"()"!==this.tokens[e-1].value||this.tokens[e-1]instanceof K)if(0==this.tokens[e].value.length)this.tokens.splice(e,1);else{if(this.tokens[e].value.length>1)throw new l(")",this.tokens[e].value[0].tokens[0]);this.tokens.splice(e,1,new K(this,"(",this.tokens[e].pos),...this.tokens[e].value[0].tokens,new K(this,")",n(this.tokens[e].value[0].tokens).pos+1))}}else if("{"===this.tokens[e].opening)if(0===e||this.tokens[e-1]instanceof Z||this.tokens[e-1]instanceof J){let t,r;if(0===this.tokens[e].value.length)t=[];else{if(1!==this.tokens[e].value.length)throw new l("}",n(this.tokens[e].value[0].tokens));t=this.tokens[e].value[0].splitByCommas(!1)}if(t.length>0&&t[0].tokens.length>0&&t[0].tokens[1]instanceof J&&":"===t[0].tokens[1].value){r=new I(this.rs,this.tokens[e].pos);for(const e of t)if(0!==e.tokens.length){if(!(e.tokens[1]instanceof J&&":"===e.tokens[1].value))throw new Error(`[${E.SYNTAX}]: Syntax Error: expected ':' but got ${e.tokens[1]??"}"}${e.tokens[1]?.pos?` at position ${e.tokens[1].pos}`:""}\n(interpreting {...} as a map as '<x> : ...' was found in first element. If you meant the operator ':', encase the first element in parenthesis)`);r.addPair(e.tokens[0],new re(this.rs,this.block,e.tokens.slice(2)))}}else t.forEach((e=>e.prepare())),r=new R(this.rs,t,this.tokens[e].pos);r.validate(),this.tokens[e]=r}else if(!(this.tokens[e-1]instanceof H&&"let"===this.tokens[e-1].value)){if(null==this.block)throw new Error(`[${E.SYNTAX}]: Syntax Error: invalid syntax '{' at position ${this.tokens[e].pos} (no enclosing block found)`);this.tokens[e]=this.block.createChild(this.tokens[e].value,this.tokens[e].pos)}if(!t)throw new Error(`[${E.SYNTAX}] Syntax Error: invalid syntax '${this.tokens[e].opening}' at position ${this.tokens[e].pos}`)}else if(this.tokens[e]instanceof J&&"<"===this.tokens[e].value&&(this.tokens[e+1]instanceof ee||this.tokens[e+1]instanceof H)&&this.tokens[e+2]instanceof J&&">"===this.tokens[e+2].value){let t=new J(this,"<cast>",this.tokens[e].pos);t.data=this.tokens[e+1].value,this.tokens.splice(e,3,t)}for(let e=0;e<this.tokens.length;e++)if(this.tokens[e]instanceof H)switch(this.tokens[e].value){case"if":if(!(this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid IF construct at position ${this.tokens[e].pos}: expected condition (...) got ${this.tokens[e+1]??"end of input"} at ${this.tokens[e].pos}`);if(!(this.tokens[e+2]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid IF construct at position ${this.tokens[e].pos}: expected block {...} got ${this.tokens[e+2]??"end of input"} at ${this.tokens[e].pos}`);{const t=new x(this.rs,this.tokens[e].pos);for(t.addBranch(this.tokens[e+1],this.tokens[e+2]),this.tokens.splice(e,3);this.tokens[e]instanceof H&&"else"===this.tokens[e].value;){if(!(this.tokens[e+1]instanceof H&&"if"===this.tokens[e+1].value)){let r=this.tokens[e+1];if(r instanceof z){t.addElse(r),this.tokens.splice(e,2);break}throw new Error(`[${E.SYNTAX}] Syntax Error: invalid ELSE construct at position ${this.tokens[e].pos}: expected block {...} got ${this.tokens[e+1]??"end of input"}`)}if(!(this.tokens[e+2]instanceof te&&"("===this.tokens[e+2].opening))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid ELSE-IF construct at position ${this.tokens[e].pos}: expected condition (...) got ${this.tokens[e+2]??"end of input"} at ${this.tokens[e].pos}`);if(!(this.tokens[e+3]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid ELSE-IF construct at position ${this.tokens[e].pos}: expected condition (...) got ${this.tokens[e+3]??"end of input"} at ${this.tokens[e].pos}`);t.addBranch(this.tokens[e+2],this.tokens[e+3]),this.tokens.splice(e,4)}t.validate(),this.tokens.splice(e,0,t)}break;case"do":this.tokens[e+1]instanceof z&&(this.tokens[e+1].breakable=1,this.tokens[e+1].prepare(),this.tokens.splice(e,1));break;case"while":{let t;if(this.tokens[e-1]instanceof z&&this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening){let r=3;if(t=new T(this.rs,this.tokens[e].pos,this.tokens[e+1],this.tokens[e-1]),this.tokens[e+2]instanceof H&&"then"===this.tokens[e+2].value){if(!(this.tokens[e+3]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid WHILE construct at position ${this.tokens[e].pos}: expected block after 'else' at position ${this.tokens[e+2].pos}`);t.thenBlock=this.tokens[e+3],r+=2}this.tokens.splice(e-1,r,t)}else{if(!(this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening&&this.tokens[e+2]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid WHILE construct at position ${this.tokens[e].pos}`);{let r=3;if(t=new A(this.rs,this.tokens[e].pos,this.tokens[e+1],this.tokens[e+2]),this.tokens[e+3]instanceof H&&"then"===this.tokens[e+3].value){if(!(this.tokens[e+4]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid WHILE construct at position ${this.tokens[e].pos}: expected block after 'else' at position ${this.tokens[e+3].pos}`);t.thenBlock=this.tokens[e+4],r+=2}this.tokens.splice(e,r,t)}}t.validate();break}case"until":{let t;if(this.tokens[e-1]instanceof z&&this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening){let r=3;if(t=new P(this.rs,this.tokens[e].pos,this.tokens[e+1],this.tokens[e-1]),this.tokens[e+2]instanceof H&&"then"===this.tokens[e+2].value){if(!(this.tokens[e+3]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid UNTIL construct at position ${this.tokens[e].pos}: expected block after 'else' at position ${this.tokens[e+2].pos}`);t.thenBlock=this.tokens[e+3],r+=2}this.tokens.splice(e-1,r,t)}else{if(!(this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening&&this.tokens[e+2]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid UNTIL construct at position ${this.tokens[e].pos}`);{let r=3;if(t=new N(this.rs,this.tokens[e].pos,this.tokens[e+1],this.tokens[e+2]),this.tokens[e+3]instanceof H&&"then"===this.tokens[e+3].value){if(!(this.tokens[e+4]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid UNTIL construct at position ${this.tokens[e].pos}: expected block after 'else' at position ${this.tokens[e+3].pos}`);t.thenBlock=this.tokens[e+4],r+=2}this.tokens.splice(e,r,t)}}t.validate();break}case"for":{let t;if(!(this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening&&this.tokens[e+2]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid FOR construct at position ${this.tokens[e].pos}`);{let r,n=3,i=this.tokens[e+1].value[0].tokens,s=[],o="VARS",a=!1;for(let e=0;e<i.length;e++){if(!("VARS"===o&&i[e]instanceof ee)){if("IN"===o&&i[e]instanceof J&&"in "===i[e].value){e++,r=new re(this.rs,this.block,i.slice(e)),a=!0;break}break}s.push(i[e]),i[e+1]instanceof J&&","===i[e+1].value?e++:o="IN"}if(t=a?new O(this.rs,this.tokens[e].pos,s,r,this.tokens[e+2]):new S(this.rs,this.tokens[e].pos,this.tokens[e+1],this.tokens[e+2]),this.tokens[e+3]instanceof H&&"then"===this.tokens[e+3].value){if(!(this.tokens[e+4]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid FOR construct at position ${this.tokens[e].pos}: expected block after 'else' at position ${this.tokens[e+3].pos}`);t.thenBlock=this.tokens[e+4],n+=2}this.tokens.splice(e,n,t)}t.validate();break}case"func":{let t=new F(this.tokens[e].pos,this.rs,{});this.tokens[e+1]instanceof ee&&(t.name=this.tokens[e+1].value,this.tokens.splice(e,1));let r,n=!0,i=0,s=0;this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening?(r=this.tokens[e+1],s=3,i=2):(s=2,i=1);let o="any";if(n&&this.tokens[e+i]instanceof J&&":"===this.tokens[e+i].value&&(i++,s++,this.tokens[e+i]instanceof ee||this.tokens[e+i]instanceof H?(o=this.tokens[e+i].value,s++,i++):n=!1),this.tokens[e+i]instanceof z?(t.body=this.tokens[e+i],t.returnType=o,this.tokens.splice(e,s,t),r&&(t.args=ie(r))):n=!1,!n)throw new Error(`[${E.SYNTAX}] Syntax Error: invalid FUNC construct at position ${t.pos}`);t.validate();break}case"loop":if(!(this.tokens[e+1]instanceof z))throw new Error(`[${E.SYNTAX}] LOOP: expected block {...} after keyword 'loop' at position ${this.tokens[e].pos}`);{let t=new B(this.rs,this.tokens[e].pos,this.tokens[e+1]);t.validate(),this.tokens.splice(e,2,t)}break;case"break":if(this.block.breakable){let t=new C(this.tokens[e].pos);t.validate(),this.tokens[e]=t}break;case"continue":if(this.block.breakable){let t=new V(this.tokens[e].pos);t.validate(),this.tokens[e]=t}break;case"return":if(this.block.returnable){let t=new re(this.rs,this.block,this.tokens.splice(e+1)??[]),r=new D(this.tokens[e].pos,t);r.validate(),this.tokens[e]=r}break;case"switch":if(!(this.tokens[e+1]instanceof te&&"("===this.tokens[e+1].opening))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct: expected condition (...) got ${this.tokens[e+1]??"end of input"} at ${this.tokens[e].pos}`);if(!(this.tokens[e+2]instanceof z))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct: expected block {...} got ${this.tokens[e+2]??"end of input"} at ${this.tokens[e].pos}`);{const t=new L(this.rs,this.tokens[e].pos,this.tokens[e+1]),r=this.tokens[e+2];this.tokens.splice(e,3);let n=r.tokenLines[0];if(!n)throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct: empty block {...} at ${r.pos}`);let i=0,s=0;for(;;){if(!n.tokens[s])throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct: unexpected end of input`);if(n.tokens[s]instanceof H&&"case"===n.tokens[s].value){let e=[],r=1;for(;;){if(!(n.tokens[s+r]instanceof te&&"("===n.tokens[s+r].opening))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct at position ${t.pos}: expected '(' following case-clause (at ${n.tokens[s].pos}), got '${n.tokens[s+r]?.toString()[0]??"end of input"}' at ${n.tokens[s+r].pos}`);if(e.push(n.tokens[s+r]),r++,!(n.tokens[s+r]instanceof J&&","===n.tokens[s+r].value))break;r++}if(!(n.tokens[s+r]instanceof te&&"{"===n.tokens[s+r].opening))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct at position ${t.pos}: expected '{' following 'case (...)', got '${n.tokens[s+2]?.toString()[0]??"end of input"}' following position ${n.tokens[s+1].pos}`);{const i=this.block.createChild(n.tokens[s+r].value,n.tokens[s+r].pos);t.addCase(e,i),s+=r+1}}else{if(!(n.tokens[s]instanceof H&&"else"===n.tokens[s].value))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct at position ${t.pos}: expected 'case' or 'else', got '${n.tokens[s]}' at ${n.tokens[s].pos}`);if(!(n.tokens[s+1]instanceof te&&"{"===n.tokens[s+1].opening))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid SWITCH construct at position ${t.pos}: expected '{' following 'else', got '${n.tokens[s+1]?.toString()[0]??"end of input"}' following position ${n.tokens[s].pos}`);{if(t.elseBlock)throw new Error(`[${E.SYNTAX}] Syntax Error: More than one else clause in switch statement at position ${n.tokens[s].pos} (previous else clause at position ${t.elseBlock.pos})`);const e=this.block.createChild(n.tokens[s+1].value,n.tokens[s+1].pos);t.addElse(e),s+=2}}if(s>=n.tokens.length&&(i++,!r.tokenLines[i]))break}t.validate(),this.tokens.splice(e,0,t)}break;case"let":if(this.tokens[e+1]instanceof ee){const t=new j(this.tokens[e].pos,this.rs,this.tokens[e+1]);t.validate(),this.tokens.splice(e,2,t)}else{if(!(this.tokens[e+1]instanceof te)||"["!==this.tokens[e+1].opening&&"{"!==this.tokens[e+1].opening||1!==this.tokens[e+1].value.length)throw new Error(`[${E.SYNTAX}] Syntax Error: expected symbol, got ${this.tokens[e+1]??"end of input"} at ${this.tokens[e].pos} in 'let' expression`);{let t=this.tokens[e+1].value[0].splitByCommas(),r=[];for(let e=0;e<t.length;e++){if(!(1===t[e].tokens.length&&t[e].tokens[0]instanceof ee))throw new Error(`[${E.SYNTAX}] Syntax Error: expected array of symbols on lhs of expression at position ${t[e].pos}, got otherwise in member ${e}`);r.push(t[e].tokens[0])}const n=new j(this.tokens[e].pos,this.rs,r);n.variation="{"===this.tokens[e+1].opening?"set":"array",n.validate(),this.tokens.splice(e,2,n)}}break;case"label":if(!(this.tokens[e+1]instanceof ee||this.tokens[e+1]instanceof H))throw new Error(`[${E.SYNTAX}] Syntax Error: expected symbolic label, got ${this.tokens[e+1]??"end of input"} at ${this.tokens[e].pos}`);{const t=new Y(this.tokens[e].pos,this.rs,this.tokens[e+1].value);t.validate(),this.tokens.splice(e,2,t)}break;case"goto":if(!(this.tokens[e+1]instanceof ee||this.tokens[e+1]instanceof H))throw new Error(`[${E.SYNTAX}] Syntax Error: expected symbolic label, got ${this.tokens[e+1]??"end of input"} at ${this.tokens[e].pos}`);{const t=new U(this.tokens[e].pos,this.rs,this.tokens[e+1].value);t.validate(),this.tokens.splice(e,2,t)}break;case"false":this.tokens.splice(e,1,new y(this.rs,!1));break;case"true":this.tokens.splice(e,1,new y(this.rs,!0))}else if(this.tokens[e]instanceof te&&"("===this.tokens[e].opening){if(this.tokens[e].value.length<2){let t=new J(this,"()",this.tokens[e].pos);t.data=[],this.tokens[e].value.length>0&&(t.data=this.tokens[e].value[0].splitByCommas()),this.tokens[e]=t}}else if(this.tokens[e]instanceof te&&"["===this.tokens[e].opening){if(1!==this.tokens[e].value.length)throw new Error(`[${E.SYNTAX}] Syntax Error: expected expression, got ] at position ${this.tokens[e].pos} (computed member access)`);{let t=new J(this,"[]",this.tokens[e].pos);t.data=this.tokens[e].value[0],t.data.prepare(),this.tokens[e]=t}}return this}async eval(e){try{return await this._eval(e)}catch(e){throw new Error(`${this.source}: \n${e} `)}}async preeval(e){for(const t of this.tokens)if("function"==typeof t.preeval&&(await t.preeval(e),0!==e.action))break}async _eval(e){const t=this.tokens,r=[];for(let n=0;n<t.length;n++){const i=t[n];if(i instanceof g||i instanceof ee)r.push(i.eval?await i.eval(e):i);else if(i instanceof J){const t=i.info();if(r.length<t.args)throw new Error(`[${E.SYNTAX}] Syntax Error: unexpected operator '${i.value}' at position ${i.pos} - stack underflow (expects ${t.args} values, got ${r.length})`);const n=r.splice(r.length-t.args),s=await i.eval(n,e);r.push(s)}else if(i instanceof z){let t=await i.eval(e);void 0!==t&&r.push(t)}else{if(!(i instanceof $)){let e,t;throw i instanceof te&&(e=i.opening),new Error(`[${E.SYNTAX}] Syntax Error: invalid syntax at position ${t??i.pos}: ${e??i.toString()} `)}{(i instanceof M||i instanceof R)&&t[n+2]instanceof J&&("="===t[n+2].value||"=>"===t[n+2].value)&&(i.assignment=!0);let s=await i.eval(e);void 0!==s&&r.push(s)}}if(0!==e.action)break}for(;r[r.length-1]instanceof v;)r.pop();if(0===r.length)return new v(this.rs);if(1!==r.length){let e=r.map((e=>e+(void 0===e.pos?"":` (position ${e.pos})`)));throw new Error(`[${E.SYNTAX}] Syntax Error: Invalid syntax ${e.join(", ")}. Did you miss an EOL token ${Q.symbol} (${Q.symbol.charCodeAt(0)}) ?\n(evaluation failed to reduce expression to single value)`)}return this.rs.setVar("ans",r[0].castTo("any"),void 0,e.pid),r[0]}toString(){return this.tokens.map((e=>e.toString())).join(" ")}toRPN(){return this._toRPN(this.tokens,this.rs.opts.value.get("bidmas").toPrimitive("bool"))}_toRPN(e,t=!0){const r=[],i=[];for(let s=0;s<e.length;s++)if(e[s]instanceof g||e[s]instanceof ee||e[s]instanceof re||e[s]instanceof te||e[s]instanceof H||e[s]instanceof $||e[s]instanceof z||e[s]instanceof Z)i.push(e[s]);else if(e[s].is?.(K,"("))r.push(e[s]);else if(e[s].is?.(K,")")){for(;n(r)instanceof G&&!n(r).is(K,"(");)i.push(r.pop());r.pop()}else if(e[s]instanceof J){const o=e[s].info();if(t)if("ltr"===o.assoc)for(;0!==r.length&&e[s].priority()<=n(r).priority();)i.push(r.pop());else for(;0!==r.length&&e[s].priority()<n(r).priority();)i.push(r.pop());else for(;0!==r.length;)i.push(r.pop());r.push(e[s])}else{if(!(e[s]instanceof Q))throw new Error(`[${E.SYNTAX}] Unknown token: ${typeof e[s]} ${e[s].constructor.name} `);if(s!==e.length-1)throw new Error(`[${E.SYNTAX}] Syntax Error: unexpected token ${e[s]}`)}for(;0!==r.length;)i.push(r.pop());return i}}function ne(e){let t=e.string,r=0,i=new re(e.rs,null),l=[];const g=(e,t)=>{if(n(l)instanceof W)throw new Error(`[${E.SYNTAX}] Syntax Error: unexpected token '${e}' at position ${t}`)};for(let v=0;v<t.length;){if('"'===t[v]){g('"',e.pos);let r="",n=v+1,o={};for(;'"'!==t[n];){if("\\"===t[n]&&t[n+1]){n++;const e=c(t,n);if(e.char){n=e.pos,r+=e.char;continue}}if("{"!==t[n]){if(void 0===t[n])throw new Error(`[${E.SYNTAX}] Syntax Error: unexpected end of input in string literal at position ${n} (literal at ${v})`);r+=t[n],n++}else{const i=s(e.rs,t.substr(n+1),e.pos+n+1,e.depth+1,["}"],!1);if(ne(i),"}"!==i.terminateOn)throw a("{","}",e.pos);if(0===i.lines.length)throw new Error(`[${E.SYNTAX}] Syntax Error: expected expression, got '}' at position ${i.pos}`);const l=t.substr(n+1,i.pos-(e.pos+n+1));let c={val:i.lines[0],src:l},u=c.val.tokens[c.val.tokens.length-1];c.val.tokens.length>1&&u instanceof J&&"="===u.value&&(c.val.tokens.pop(),c.eq=!0),o[r.length]=c,n+=l.length+2}}l.push(new W(i,new m(e.rs,r,o),v));const u=n-v+1;v+=u,e.pos+=u;continue}if("'"===t[v]){g("'",e.pos);let r="",n=v+1;for(;"'"!==t[n];){if("\\"===t[n]){n++;const e=c(t,n);if(e.char){n=e.pos,r+=e.char;continue}}if(void 0===t[n])throw new Error(`[${E.SYNTAX}] Syntax Error: unexpected end of input in char literal at position ${n} (literal at ${v})`);r+=t[n],n++}if(r.length>1)throw new Error(`[${E.SYNTAX}] Syntax Error: multi-character character literal at position ${v}. Did you mean to use double quotes: "${t.substring(v+1,n)}" ?`);l.push(new W(i,new _(e.rs,r),v));const s=n-v+1;v+=s,e.pos+=s;continue}if(e.terminateOn.includes(t[v])){e.terminateOn=t[v];break}if(e.allowMultiline&&t[v]===Q.symbol){l.push(new Q(i,e.pos)),v++,e.pos++,i.updateTokens(l),i.source=t.substr(r,v).trim(),e.lines.push(i),r=v,l=[],i=new re(e.rs,null);continue}if(o(t[v])){v++,e.pos++;continue}if("/"===t[v]&&"/"===t[v+1]){let r="";for(v+=3,e.pos+=3;v<t.length;v++,e.pos++){if("\n"===t[v]||"\r"===t[v]){v++,e.pos++;break}r+=t[v]}i.comment=r;continue}if("/"===t[v]&&"*"===t[v+1]){let r="";for(v+=3,e.pos+=3;v<t.length;v++,e.pos++){if("*"===t[v]&&"/"===t[v+1]){v+=2,e.pos+=2;break}r+=t[v]}i.comment=r;continue}if(t[v]in u){if(-1!==u[t[v]]){const r=t[v],n=h[r],o=s(e.rs,t.substr(v+1),e.pos+1,e.depth+1,[n],!0);ne(o);const c=o.pos-e.pos+1;if(o.terminateOn!==n)throw a(r,n,e.pos);const u=new te(i,o.lines,r,e.pos);l.push(u),e.pos+=c,v+=c;continue}a(t[v],h[t[v]],e.pos)}if("..."===t.substr(v,3)){l.push(new Z(i,e.pos)),v+=3,e.pos+=3;continue}let y,b=f(t.substr(v));if(null!==b){const t=new J(i,b,e.pos),r=n(l);t.info().unary&&(void 0===r||r instanceof K&&1===r.facing()||r instanceof J)&&(t.isUnary=!0),l.push(t),v+=b.length,e.pos+=b.length;continue}try{y=p(t.substr(v),!0,"_",q.imagLetter)}catch(t){throw new Error(`[${E.SYNTAX}] Syntax Error: ${t.message} (literal at position ${e.pos})`)}if(y.str.length>0){g(y.str,e.pos);const t=new W(i,new w(e.rs,y.imag?new q(0,y.num):y.num),e.pos);l.push(t),v+=y.pos,e.pos+=y.pos;continue}let k=d(t.substr(v));if(null===k)throw new Error(`[${E.SYNTAX}] Syntax Error: unexpected token '${t[v]}' (${t[v].charCodeAt(0)}) at position ${e.pos} `);{if(e.terminateOn.includes(k)){e.terminateOn=k,v+=k.length,e.pos+=k.length;break}if("begin"===k){const r="begin",n="end",o=s(e.rs,t.substr(v+r.length),e.pos+r.length,e.depth+1,[n],!0);ne(o);const c=o.pos-e.pos;o.terminateOn!==n&&a(r,n,e.pos);const u=new te(i,o.lines,"{",e.pos);l.push(u),e.pos+=c,v+=c;continue}let r;H.keywords.includes(k)?r=new H(i,k,e.pos):(g(k,e.pos),r=new ee(i,k,e.pos)),l.push(r),v+=k.length,e.pos+=k.length}}l.length>0&&(i.updateTokens(l),i.source=t.substr(r).trim(),e.lines.push(i))}function ie(e){let t={},r=null,n=!1;if(1===e.value.length){let i=e.value[0].splitByCommas(!1);for(let e of i){let i,s={},o=!0,a=0;if("..."===e.tokens[a].value){if(n)throw new Error(`[${E.SYNTAX}] Syntax Error: only one parameter may have '...' , found second at position ${e.tokens[a].pos}`);s.ellipse=!0,n=!0,a++}if(e.tokens[a]instanceof J&&"?"===e.tokens[a].value&&(s.optional=!0,a++),!(void 0!==e.tokens[a]&&e.tokens[a]instanceof ee))throw new Error(`[${E.SYNTAX}] Syntax Error: expected parameter name, got ${e.tokens[a]} at position ${e.tokens[a]?.pos}`);if(i=e.tokens[a],i.value in t)throw new Error(`[${E.NAME}] Name Error: Duplicate parameter name '${i.value}' at position ${i.pos}`);if(s.optional&&(r=i.value),a++,e.tokens[a]instanceof J&&":"===e.tokens[a].value){if(a++,e.tokens[a]instanceof ee&&(e.tokens[a+1]instanceof ee||e.tokens[a+1]instanceof H||e.tokens[a+1]instanceof J&&"?"===e.tokens[a+1].value)){if("val"!==e.tokens[a].value&&"ref"!==e.tokens[a].value)throw new Error(`[${E.SYNTAX}] Syntax Error: expected pass-by indicator, got ${e.tokens[a].value} (position ${e.tokens[a].pos})`);if(s.pass=e.tokens[a].value,"ref"===s.pass&&s.optional)throw new Error(`[${E.SYNTAX}] Syntax Error: optional parameter '${i.value}' cannot be marked as pass-by-reference (position ${e.tokens[a].pos})`);a++}if(o){if(void 0===e.tokens[a])throw new Error(`[${E.SYNTAX}] Syntax Error: expected type indicator, got EOL${e.tokens[a-1]?" (position "+e.tokens[a-1].pos+")":""}`);if(!(e.tokens[a]instanceof ee||e.tokens[a]instanceof H))throw new Error(`[${E.SYNTAX}] Syntax Error: expected type indicator, got ${e.tokens[a].value} (position ${e.tokens[a].pos})`);s.type=e.tokens[a].value,a++}}if(o&&e.tokens[a])if(e.tokens[a]instanceof J&&"="===e.tokens[a].value)if(a++,e.tokens[a]instanceof G){if("ref"===s.pass)throw new Error(`[${E.SYNTAX}] Syntax Error: unexpected token '=' at position ${e.tokens[a].pos}: ${s.pass} parameter '${i.value}' cannot have a default value`);s.optional=!0,s.default=e.tokens[a],s.default instanceof W?s.default=s.default.value:s.default instanceof te&&s.default.prepare(),a++}else o=!1;else o=!1;if(o&&void 0!==e.tokens[a]&&(o=!1),!o)throw new Error(`[${E.SYNTAX}] Syntax Error: FUNCTION: invalid syntax in parameter '${i.value}' at position ${i.pos}`);if(r&&!s.optional)throw new Error(`[${E.SYNTAX}] Syntax Error: required argument '${i.value}' cannot precede optional argument '${r}' (position ${i.pos})`);if(s.ellipse&&(n=!0,void 0!==s.pass&&"val"!==s.pass))throw new Error(`[${E.SYNTAX}] Syntax Error: invalid pass-by type for '...' parameter '${i.value}' at ${i.pos}: ${s.pass}`);t[i.value]=s}}return t}e.exports={Token:G,BracketToken:K,VariableToken:ee,OperatorToken:J,TokenLine:re,KeywordToken:H,BracketedTokenLine:te,tokenify:function(e,t,r=!1){const n=s(e,t,0,0);return n.allowMultiline=!r,ne(n),n.lines}}},880:(e,t,r)=>{const{errors:n}=r(365),i=new Set,s=new Map;function o(e,t=[]){i.add(e),s.set(e,"*"===t?"*":new Set(t))}function a(e){return"function"==typeof e.type?e.type():void 0===e?"undefined":null===e?"null":"unknown"}o("any","*"),o("complex",["complex_int"]),o("complex_int"),o("real",["bool","real_int","complex"]),o("real_int",["bool"]),o("string"),o("char",["string"]),o("bool"),o("array"),o("set"),o("map"),o("func"),e.exports={types:i,isNumericType:e=>"complex"===e||"complex_int"===e||"real"===e||"real_int"===e||"bool"===e||"char"===e,isIntType:e=>"real_int"===e||"complex_int"===e||"bool"===e||"char"===e,isRealType:e=>"real_int"===e||"real"===e||"bool"===e||"char"===e,castingError:function(e,t,r=!1){if(i.has(t))throw new Error(`[${n.CAST_ERROR}] Type Error: Cannot ${r?"implicitly ":""}cast ${typeof e} ${a(e)} to ${t}`);throw new Error(`[${n.TYPE_ERROR}] Type Error: unknown type '${t}'`)},typeOf:a,addType:o,isTypeOverlap:function e(t,r){if(t===r||"any"===t||"any"===r)return!0;let n=s.get(t);if(void 0===n)return!1;if("*"===n||n.has(r))return!0;for(let t of n)if(e(t,r))return!0;return!1},typeOverlap:s}},444:(e,t,r)=>{const n=r(397),{range:i}=r(787),{RunspaceFunction:s}=r(225),{str:o,removeDuplicates:a,arrDifference:l,intersect:c,arrRepeat:u,findIndex:h,equal:p,peek:f,toJson:d}=r(89),{castingError:m,isNumericType:w,isRealType:g}=r(880),{errors:v}=r(365);class _{constructor(e,t){this.rs=e,this.value=t,this.onAssign=void 0,this.getAssignVal=void 0}type(){throw new Error("Requires Overload")}castTo(e){if("any"===e||e===this.type())return this;if("*"===f(e))throw new Error(`[${v.CAST_ERROR}] Type Error: Cannot cast object ${this.type()} to ${e} (reference)`);const t=this.constructor.castMap;let r=t&&e in t?t[e](this):void 0;return void 0===r&&m(this,e),r}toPrimitive(e){const t=this.castTo(e).value;return e.startsWith("real")?t.a:t}toString(){return this.toPrimitive("string")}getAssignError(){return new Error(`[${v.TYPE_ERROR}] Type Error: Cannot assign to object ${this.type()}`)}__assign__(e){if(void 0===this.onAssign)throw this.getAssignError();return this.onAssign(e.castTo("any"))}__assignAdd__(e){if(void 0===this.onAssign)throw this.getAssignError();return this.onAssign(this.getAssignVal().__add__(e.castTo("any")))}__assignSub__(e){if(void 0===this.onAssign)throw this.getAssignError();return this.onAssign(this.getAssignVal().__sub__(e.castTo("any")))}__assignMul__(e){if(void 0===this.onAssign)throw this.getAssignError();return this.onAssign(this.getAssignVal().__mul__(e.castTo("any")))}__assignDiv__(e){if(void 0===this.onAssign)throw this.getAssignError();return this.onAssign(this.getAssignVal().__div__(e.castTo("any")))}__assignMod__(e){if(void 0===this.onAssign)throw this.getAssignError();return this.onAssign(this.getAssignVal().__mod__(e.castTo("any")))}__pos__(){return this.castTo("complex")}__neg__(){return new b(this.rs,n.mult(this.toPrimitive("complex"),-1))}__not__(){return new x(this.rs,!this.toPrimitive("bool"))}__in__(e){const t=e.type();if("array"===t||"set"===t)return new x(this.rs,-1!==h(this,e.toPrimitive("array")));if("string"===t)return new x(this.rs,-1!==e.toString().indexOf(this.toString()));if("map"===t)return new x(this.rs,e.value.has(this.toString()));throw new Error(`[${v.TYPE_ERROR}] Type Error: object ${t} is not a collection`)}__neq__(e){return new x(this.rs,!this.__eq__(e).toPrimitive("bool"))}__and__(e){return this.toPrimitive("bool")&&e.toPrimitive("bool")?e:new x(this.rs,!1)}__or__(e){return this.toPrimitive("bool")?this:e.toPrimitive("bool")?e:new x(this.rs,!1)}}class y extends _{constructor(e){super(e,void 0)}type(){return"undef"}__eq__(e){return new x(this.rs,e instanceof y)}__copy__(){return new y(this.rs)}__toJson__(){return"null"}}class b extends _{constructor(e,t=0){super(e,n.assert(t))}type(){return this.value.isReal()?"real":"complex"}__abs__(){return n.abs(this.value)}__copy__(){return new b(this.rs,this.value.copy())}__reverse__(){let e=this.value.a.toLocaleString("fullwide",{useGrouping:!1}).split("").reverse().join(""),t=this.value.b.toLocaleString("fullwide",{useGrouping:!1}).split("").reverse().join("");return new b(this.rs,new n(+e,+t))}__deg__(){return new b(this.rs,n.mult(this.value,Math.PI/180))}__eq__(e){return new x(this.rs,!!w(e.type())&&this.value.equals(e.toPrimitive("complex")))}__bitwiseNot__(){if(g(this.type()))return new b(this.rs,~this.value.a)}__bitwiseAnd__(e){if(g(this.type())&&g(e.type()))return new b(this.rs,this.toPrimitive("real")&e.toPrimitive("real"))}__bitwiseOr__(e){if(g(this.type())&&g(e.type()))return new b(this.rs,this.toPrimitive("real")|e.toPrimitive("real"))}__xor__(e){if(g(this.type())&&g(e.type()))return new b(this.rs,this.toPrimitive("real")^e.toPrimitive("real"))}__pow__(e){if(w(e.type()))return new b(this.rs,n.pow(this.toPrimitive("complex"),e.toPrimitive("complex")))}__div__(e){if(w(e.type()))return new b(this.rs,n.div(this.toPrimitive("complex"),e.toPrimitive("complex")))}__mod__(e){if(w(e.type()))return new b(this.rs,n.modulo(this.toPrimitive("complex"),e.toPrimitive("complex")))}__mul__(e){const t=e.type();if("string"===t||w(t))return new b(this.rs,n.mult(this.toPrimitive("complex"),e.toPrimitive("complex")))}__add__(e){const t=e.type();return"undefined"===t?new b(this.rs,NaN):"string"===t?new k(this.rs,this.toPrimitive("string")+e.toPrimitive("string")):w(t)?new b(this.rs,n.add(this.toPrimitive("complex"),e.toPrimitive("complex"))):void 0}__sub__(e){const t=e.type();if("string"===t||w(t))return new b(this.rs,n.sub(this.toPrimitive("complex"),e.toPrimitive("complex")))}__lshift__(e){const t=e.type();if(g(this.type())&&g(t))return new b(this.rs,this.toPrimitive("real")<<e.toPrimitive("real"))}__rshift__(e){const t=e.type();if(g(this.type())&&g(t))return new b(this.rs,this.toPrimitive("real")>>e.toPrimitive("real"))}__le__(e){if(g(this.type())&&g(e.type()))return new x(this.rs,this.toPrimitive("real")<=e.toPrimitive("real"))}__lt__(e){if(g(this.type())&&"real"===e.type())return new x(this.rs,this.toPrimitive("real")<e.toPrimitive("real"))}__ge__(e){if(g(this.type())&&g(e.type()))return new x(this.rs,this.toPrimitive("real")>=e.toPrimitive("real"))}__gt__(e){if(g(this.type())&&g(e.type()))return new x(this.rs,this.toPrimitive("real")>e.toPrimitive("real"))}__seq__(e){const t=e.type();if(g(t)&&0===this.value.b){let t=i(this.toPrimitive("real_int"),e.toPrimitive("real_int"));return new $(this.rs,t.map((e=>new b(this.rs,e))))}}__toJson__(){return n.isNaN(this.value)||!n.isFinite(this.value)?"null":g(this.type())?this.toPrimitive("real").toString():void 0}}class k extends _{constructor(e,t="",r={}){super(e,o(t)),this.intpls=r}type(){return"string"}__toJson__(){return'"'+this.value.replace(/[\\$'"]/g,"\\$&")+'"'}async eval(e){if(0===Object.keys(this.intpls).length)return this;let t=new k(this.rs,this.value),r=0;for(let n in this.intpls)if(this.intpls.hasOwnProperty(n))try{const i=this.intpls[n];let s=(await i.val.eval(e)).toString();i.eq&&(s=i.src+s);let o=+n+r;t.value=t.value.substr(0,o)+s+t.value.substr(o),r+=s.length}catch(e){throw new Error(`[${v.GENERAL}] Error whilst interpolating string (index ${n}):\n${e}`)}return t}__len__(e){return void 0!==e&&(e>this.value.length?this.value+=String.fromCharCode(0).repeat(e-this.value.length):this.value=this.value.substr(0,e)),this.value.length}__get__(e){if((e=e.toPrimitive("real_int"))<0&&(e=this.value.length+e),e<0||e>=this.value.length)return new y(this.rs);const t=new k(this.rs,this.value[e]);return t.onAssign=t=>this.__set__(e,t),t.getAssignVal=()=>t,t}__set__(e,t){return(e="number"==typeof e?e:e.toPrimitive("real_int"))<0&&(e=this.value.length+e),e<0||e>=this.value.length?new y(this.rs):(t=t.castTo("char").toString(),this.value=this.value.substring(0,e)+t+this.value.substr(e+1),this)}__del__(e){let t=e.toPrimitive("real_int");if(isNaN(t)||t<0||t>=this.value.length)return new y(this.rs);const r=this.value[t];return this.value=this.value.substring(0,t)+this.value.substr(t+1),new k(this.rs,r)}__find__(e){return new b(this.rs,this.value.indexOf(e.toPrimitive("string")))}__reverse__(){return new k(this.rs,this.value.split("").reverse().join(""))}__copy__(){return new k(this.rs,this.value)}__min__(){return 0===this.value.length?this.rs.UNDEFINED:new E(this.rs,Math.min(...this.value.split("").map((e=>e.charCodeAt(0)))))}__max__(){return 0===this.value.length?this.rs.UNDEFINED:new E(this.rs,Math.max(...this.value.split("").map((e=>e.charCodeAt(0)))))}__iter__(){return this.value.split("")}__eq__(e){let t=!1,r=e.type();return"string"===r?t=this.toString()===e.toString():"char"===r&&(t=1===this.value.length&&this.value.charCodeAt(0)===e.value),new x(this.rs,t)}__mul__(e){if("real"===e.type())return e=e.toPrimitive("real_int"),new k(this.rs,e<0?"":this.toString().repeat(e))}__add__(e){return new k(this.rs,this.toPrimitive("string")+e.toPrimitive("string"))}__seq__(e){if("string"===e.type()){if(1!==this.value.length)throw new Error(`[${v.TYPE_ERROR}] Type Error: expected char, got string "${this.value}"`);if(1!==e.value.length)throw new Error(`[${v.TYPE_ERROR}] Type Error: expected char, got string "${e.value}"`);let t=i(this.value.charCodeAt(0),e.value.charCodeAt(0));return new $(this.rs,t.map((e=>new k(this.rs,String.fromCharCode(e)))))}}__mod__(e){let t=e.type(),r="array"===t||"set"===t?e.toPrimitive("array"):[e];return this.format(r)}format(e){let t="",r=this.value,n=0;for(let i=0;i<r.length;i++)if("%"===r[i]){let s=r[++i];if(void 0===s)throw new Error(`[${v.SYNTAX}] Syntax Error: incomplete formatting option at index ${i-1}`);if(void 0===e[n])t+="%"+s;else if("%"===s)t+="%";else if("s"===s)t+=e[n++].toPrimitive("string");else if("n"===s)t+=e[n++].toPrimitive("complex").toString();else if("i"===s)t+=e[n++].toPrimitive("complex_int").toString();else if("c"===s&&"i"===r[i+1])i++,t+=e[n++].toPrimitive("complex_int").toString();else if("r"===s&&"i"===r[i+1])i++,t+=e[n++].toPrimitive("real_int").toString();else if("c"===s)t+=e[n++].castTo("char").toString();else if("b"===s)t+=e[n++].toPrimitive("bool").toString();else if("o"===s)t+=e[n++].toPrimitive("complex").toString(8);else if("d"===s)t+=e[n++].toPrimitive("complex").toString(10);else if("x"===s)t+=e[n++].toPrimitive("complex").toString(16,"lower");else if("X"===s)t+=e[n++].toPrimitive("complex").toString(16,"upper");else{if("e"!==s)throw new Error(`[${v.SYNTAX}] Syntax Error: unknown formatting option '${s}' (0x${s.charCodeAt(0).toString(16)}) at index ${i-1}`);t+=e[n++].toPrimitive("complex").toExponential()}}else t+=r[i];if(n<e.length)for(;n<e.length;n++)t+=" "+e[n].toPrimitive("string");return new k(this.rs,t)}}class E extends _{constructor(e,t=0){if(""===t&&(t=0),t instanceof n)throw new Error("CharValue: complex value not allowed!");super(e,"number"==typeof t?t:o(t[0]).charCodeAt(0))}type(){return"char"}__abs__(){return this.value}__copy__(){return new E(this.rs,this.value)}__toJson__(){return this.castTo("string").__toJson__()}__eq__(e){let t=e.type(),r=!1;return"char"===t?r=this.value===e.value:"string"===t?r=1===e.value.length&&this.value===e.value.charCodeAt(0):"real"===t?r=this.value===e.value.a:"bool"===t&&(r=this.value===e.value),new x(this.rs,r)}__bitwiseNot__(){return new E(this.rs,~this.value)}__bitwiseAnd__(e){if(g(e.type()))return new E(this.rs,this.value&e.toPrimitive("real"))}__bitwiseOr__(e){if(g(e.type()))return new E(this.rs,this.value|e.toPrimitive("real"))}__xor__(e){if(g(e.type()))return new E(this.rs,this.value^e.toPrimitive("real"))}__pow__(e){if(g(e.type()))return new E(this.rs,Math.pow(this.value,e.toPrimitive("real")))}__div__(e){if(g(e.type()))return new E(this.rs,this.value/e.toPrimitive("real"))}__mod__(e){if(g(e.type()))return new E(this.rs,this.value%e.toPrimitive("real"))}__mul__(e){const t=e.type();if("string"===t||g(t))return new E(this.rs,this.value*e.toPrimitive("real"))}__add__(e){const t=e.type();if("string"===t||g(t))return new E(this.rs,this.value+e.toPrimitive("real"))}__sub__(e){const t=e.type();if("string"===t||g(t))return new E(this.rs,this.value-e.toPrimitive("real"))}__lshift__(e){const t=e.type();if(g(t))return new E(this.rs,this.value<<e.toPrimitive("real"))}__rshift__(e){const t=e.type();if(g(t))return new E(this.rs,this.value>>e.toPrimitive("real"))}__le__(e){if(g(e.type()))return new x(this.rs,this.value<=e.toPrimitive("real"))}__lt__(e){if("real"===e.type())return new x(this.rs,this.value<e.toPrimitive("real"))}__ge__(e){if(g(e.type()))return new x(this.rs,this.value>=e.toPrimitive("real"))}__gt__(e){if(g(e.type()))return new x(this.rs,this.value>e.toPrimitive("real"))}__seq__(e){const t=e.type();if(w(t)){let t=i(this.toPrimitive("real_int"),e.toPrimitive("real_int"));return new $(this.rs,t.map((e=>new b(this.rs,e))))}}}class x extends _{constructor(e,t=!1){super(e,!!t)}type(){return"bool"}__copy__(){return new x(this.rs,this.value)}__toJson__(){return this.value?"true":"false"}__eq__(e){return new x(this.rs,!!w(e.type())&&this.value===e.toPrimitive("bool"))}__bitwiseNot__(){return new b(this.rs,~this.value)}__bitwiseAnd__(e){const t=e.type();if(g(t))return new b(this.rs,this.toPrimitive("real")&e.toPrimitive("real"))}__bitwiseOr__(e){const t=e.type();if(g(t))return new b(this.rs,this.toPrimitive("real")|e.toPrimitive("real"))}__xor__(e){const t=e.type();if(g(t))return new b(this.rs,this.toPrimitive("real")^e.toPrimitive("real"))}__add__(e){if(w(e.type()))return new b(this.rs,n.add(this.toPrimitive("real"),e.toPrimitive("complex")))}}class $ extends _{constructor(e,t=[],r=!0){super(e,r?t.map((e=>e.castTo("any"))):t)}type(){return"array"}__iter__(){return this.value}__len__(e){if(void 0!==e)if(e>this.value.length)for(;e>this.value.length;)this.value.push(this.rs.UNDEFINED);else this.value.length=e;return this.value.length}__abs__(){return this.value.length}__toJson__(){return"["+this.value.map((e=>d(e))).join(",")+"]"}__min__(){return 0===this.value.length?this.rs.UNDEFINED:new b(this.rs,Math.min(...this.value.map((e=>e.toPrimitive("real")))))}__max__(){return 0===this.value.length?this.rs.UNDEFINED:new b(this.rs,Math.max(...this.value.map((e=>e.toPrimitive("real")))))}__get__(e){(e=e.toPrimitive("real_int"))<0&&(e=this.value.length+e);const t=isNaN(e)||e<0||e>=this.value.length?new y(this.rs):this.value[e];return t.onAssign=t=>this.__set__(e,t),t.getAssignVal=()=>this.value[e],t}__set__(e,t){if((e="number"==typeof e?e:e.toPrimitive("real_int"))<0&&(e=this.value.length+e),isNaN(e)||e<0)return new y(this.rs);if(e>=this.value.length)for(let t=this.value.length;t<e;t++)this.value[t]=new y(this.rs);return this.value[e]=t,this}__del__(e){let t=e.toPrimitive("real_int");return isNaN(t)||t<0||t>=this.value.length?new y(this.rs):(this.value.splice(t,1),new b(this.rs,t))}__reverse__(){return this.value.reverse(),this}__find__(e){return new b(this.rs,h(e,this.value))}__copy__(){const e=(e,t)=>`[${v.CANT_COPY}] Type Error: Error whilst copying type array:\n[${v.CANT_COPY}] Index ${t}: type ${e.type()} cannot be copied`;return new $(this.rs,this.value.map(((t,r)=>{let n;try{n=t.__copy__?.()}catch(n){throw new Error(`${e(t,r)}\n${n}`)}if(void 0===n)throw new Error(e(t,r));return n})))}__assignTemplate(e,t){if("array"===e.type())try{let r=this.value.length,n=[];for(let i=0;i<r;i++){if("function"!=typeof this.value[i][t])throw new Error(`[${v.TYPE_ERROR}] Type Error: Unable to unpack arrays: cannot assign to type ${this.value[i].type()} (${this.value[i]})`);n.push(e.value[i]?e.value[i].castTo("any"):this.rs.UNDEFINED)}for(let e=0;e<this.value.length;e++)this.value[e][t](n[e]);return this}catch(t){throw new Error(`[${v.BAD_ARG}] Errors whilst unpacking array[${e.value.length}] into array[${this.value.length}]:\n${t}`)}}__assign__(e){return this.__assignTemplate(e,"__assign__")}__nonlocalAssign__(e){return this.__assignTemplate(e,"__nonlocalAssign__")}__eq__(e){return new x(this.rs,"array"===e.type()&&this.value.length===e.value.length&&this.value.map(((t,r)=>p(this.value[r],e.value[r]))).every((e=>e)))}__mul__(e){const t=e.type();return"array"===t?new $(this.rs,c(this.toPrimitive("array"),e.toPrimitive("array"))):"real"===t?new $(this.rs,u(this.toPrimitive("array"),e.toPrimitive("real_int"))):void 0}__add__(e){const t=e.type();return new $(this.rs,"array"===t?this.toPrimitive("array").concat(e.toPrimitive("array")):[...this.toPrimitive("array"),e])}__sub__(e){if("array"===e.type())return new $(this.rs,l(this.toPrimitive("array"),e.toPrimitive("array")))}}class A extends _{constructor(e,t=[]){super(e,t),this.check()}check(){this.value=a(this.value)}type(){return"set"}__len__(e){if(void 0!==e){if(e>this.value.length)throw new Error(`[${v.TYPE_ERROR}] Type Error: cannot set len() of type ${this.type()}`);this.value.splice(this.value.length-e)}return this.value.length}__toJson__(){return"["+this.value.map((e=>d(e)))+"]"}__abs__(){return this.value.length}__min__(){return 0===this.value.length?this.rs.UNDEFINED:new k(this.rs,Math.min(...this.value.map((e=>e.toPrimitive("real")))))}__max__(){return 0===this.value.length?this.rs.UNDEFINED:new k(this.rs,Math.max(...this.value.map((e=>e.toPrimitive("real")))))}__reverse__(){return this.value.reverse(),this}__find__(e){return new b(this.rs,h(e,this.value))}__copy__(){const e=(e,t)=>`[${v.CANT_COPY}] Error whilst copying type set: index ${t}: type ${e.type()} cannot be copied`;return new A(this.rs,this.value.map(((t,r)=>{let n;try{n=t.__copy__?.()}catch(n){throw new Error(`${e(t,r)}\n${n}`)}if(void 0===n)throw new Error(e(t,r));return n})))}__iter__(){return this.value}run(e){let t=e(this);return this.check(),t}__eq__(e){return new x(this.rs,"set"===e.type()&&this.value.length===e.value.length&&this.value.map((t=>-1!==h(t,e.value))).every((e=>e)))}__not__(){const e=this.rs.getVar("universal_set")?.castTo("any");return null==e?new Error("Type Error: variable universal_set is missing."):"set"!==e.type()?new Error(`Type Error: variable universal_set is not of type set (got ${e.type()})`):new A(this.rs,l(e.toPrimitive("array"),this.toPrimitive("array")))}__mul__(e){if("set"===e.type())return new A(this.rs,c(this.toPrimitive("array"),e.toPrimitive("array")))}__add__(e){const t=e.type();return new A(this.rs,"set"===t?this.toPrimitive("array").concat(e.toPrimitive("array")):[...this.toPrimitive("array"),e])}__sub__(e){if("set"===e.type())return new A(this.rs,l(this.toPrimitive("array"),e.toPrimitive("array")))}__assignTemplate(e,t){if("map"===e.type())try{let r=new Map;for(let n=0;n<this.value.length;n++){if("function"!=typeof this.value[n][t])throw new Error(`[${v.TYPE_ERROR}] Type Error: Unable to unpack arrays: cannot assign to type ${this.value[n].type()} (${this.value[n]})`);let i=this.value[n].value;r.set(i,e.value.has(i)?e.value.get(i).castTo("any"):this.rs.UNDEFINED)}for(let e=0;e<this.value.length;e++){let n=this.value[e].value;this.value[e][t](r.get(n))}return this}catch(t){throw new Error(`[${v.BAD_ARG}] Errors whilst unpacking array[${e.value.length}] into array[${this.value.length}]:\n${t}`)}}__assign__(e){return this.__assignTemplate(e,"__assign__")}__nonlocalAssign__(e){return this.__assignTemplate(e,"__nonlocalAssign__")}}class T extends _{constructor(e,t){super(e,null),this.value=void 0===t?new Map:t,this.inheritFrom=new Set,this.instanceOf=void 0}type(){return"map"}createInstance(){let e=new Map;this._passCreateInstanceValues(e);let t=new T(this.rs,e);return t.instanceOf=this,t}_passCreateInstanceValues(e){return this.value.forEach(((t,r)=>{(t=t.castTo("any"))instanceof S||e.set(r,t.__copy__())})),this.inheritFrom.forEach((t=>t._passCreateInstanceValues(e))),e}isInstanceOf(e){if(this.instanceOf===e)return!0;for(let t of this.inheritFrom)if(t===e)return!0;if(this.instanceOf)for(let t of this.instanceOf.inheritFrom)if(t===e)return!0;for(let t of this.inheritFrom)if(t.isInstanceOf(e))return!0;if(this.instanceOf)for(let t of this.instanceOf.inheritFrom)if(t.isInstanceOf(e))return!0;return!1}__len__(e){if(void 0!==e){if(0!==e)throw new Error(`[${v.TYPE_ERROR}] Type Error: cannot set non-zero len() of type ${this.type()}`);this.value.clear()}return this.value.size}__abs__(){return this.value.size}__toJson__(){return"{"+Array.from(this.value.entries()).map((([e,t])=>'"'+e+'":'+d(t))).join(",")+"}"}__min__(){if(0===this.value.size)return this.rs.UNDEFINED;let e,t=new b(this.rs,1/0);return this.value.forEach(((r,n)=>{r.__lt__?.(t).toPrimitive("bool")&&(e=n,t=r)})),e?new k(this.rs,e):e}__max__(){if(0===this.value.size)return this.rs.UNDEFINED;let e,t=new b(this.rs,-1/0);return this.value.forEach(((r,n)=>{r.__gt__?.(t).toPrimitive("bool")&&(e=n,t=r)})),e?new k(this.rs,e):e}__getRaw(e){let t=this.value.has(e)?this.value.get(e):void 0;if(!t&&this.instanceOf&&(t=this.instanceOf.__getRaw(e),t instanceof S&&(t=t.__copy__(),t.prependArgs.push(this))),!t)for(let r of this.inheritFrom)if(t=r.__getRaw(e),t)break;return t}__get__(e){e=e.toString();let t=this.__getRaw(e)??new y(this.rs);return t.onAssign=t=>this.__set__(e,t),t.getAssignVal=()=>this.value.get(e),t}__set__(e,t){return e=e.toString(),this.value.set(e,t),this}__del__(e){if(e=e.toString(),!this.value.has(e))return new y(this.rs);const t=this.value.get(e);return this.value.delete(e),t}__find__(e){for(const[t,r]of this.value.entries())if(p(e,r))return new k(this.rs,t);return new y(this.rs)}__copy__(){const e=(e,t)=>`[${v.CANT_COPY}] Error whilst copying type map: key ${t}: type ${e.type()} cannot be copied`,t=new T(this.rs);return this.value.forEach(((r,n)=>{let i;try{i=r.__copy__?.()}catch(t){throw new Error(`${e(r,n)}\n${t}`)}if(void 0===i)throw new Error(e(r,n));t.value.set(n,i)})),t}async __call__(e,t){let r=this.createInstance();if(this.value.has("_Construct")){let n,i=this.value.get("_Construct").castTo("any");if(i=i.getFn?i.getFn():i,!(i instanceof s))throw new Error(`[${v.TYPE_ERROR}] Type Error: expected _Construct to be a function, got ${i.type()}`);{let s=Object.keys(i.rargs)[0],o=s?i.args.get(s):void 0;if(!o||"ref"!==o.pass||"map"!==o.type||!1!==o.optional||!1!==o.ellipse)throw new Error(`[${v.BAD_ARG}] Argument Error: First argument of _Construct should match '${s??"obj"}: ref map', got '${s?i.argumentSignature(s):""}'`);try{n=await i.call(e,[r,...t])}catch(e){throw new Error(`[${v.GENERAL}] _Construct ${i.signature()}:\n${e}`)}}}return r}__iter__(){return Array.from(this.value.entries()).map((([e,t])=>[new k(this.rs,e),t]))}__eq__(e){let t=!1;if("map"===e.type()){let r=Array.from(this.value.entries()),n=Array.from(e.value.entries());t=r.length===n.length&&r.map((t=>p(this.value.get(t[0]),e.value.get(t[0])))).every((e=>e))}return new x(this.rs,t)}}class S extends _{constructor(e,t){super(e,t),this.prependArgs=[]}type(){return"func"}exists(){return void 0!==this.value}getFn(){return this.value}toString(){return`<func ${this.value.name}>`}async __call__(e,t){const r=this.getFn();if(this.prependArgs.length>0&&(t=[...this.prependArgs,...t]),r)try{return await r.call(e,t)}catch(e){throw new Error(`[${v.GENERAL}] Function ${r.signature()}:\n${e}`)}else this._throwNullRef()}_throwNullRef(){throw new Error(`[${v.NULL_REF}] Null Reference: reference to undefined function ${this}`)}__copy__(){return new S(this.rs,this.value)}__eq__(e){return new x(this.rs,"func"===e.type()&&this.value===e.value)}}_.typeMap={complex:b,complex_int:b,real:b,real_int:b,string:k,char:E,bool:x,array:$,set:A,map:T},_.__new__=(e,t)=>{if(t in _.typeMap)return new _.typeMap[t](e)},y.castMap={string:e=>new k(e.rs,"undef"),char:e=>new E(e.rs,0),complex:e=>new b(e.rs,NaN),complex_int:e=>new b(e.rs,NaN),real:e=>new b(e.rs,NaN),real_int:e=>new b(e.rs,NaN),bool:e=>new x(e.rs,!1)},b.castMap={complex:e=>e,complex_int:e=>new b(e.rs,n.floor(e.value)),real:e=>new b(e.rs,e.value.a),real_int:e=>new b(e.rs,Math.floor(e.value.a)),string:e=>{let t;return t=isNaN(e.value.a)||isNaN(e.value.b)?"nan":0!==e.value.b||isFinite(e.value.a)?isFinite(e.value.a)&&isFinite(e.value.b)?o(e.value):"inf":e.value.a<0?"-inf":"inf",new k(e.rs,t)},char:e=>new E(e.rs,Math.floor(e.value.a)),bool:e=>0===e.value.b?new x(e.rs,!!e.value.a):0===e.value.a?new x(e.rs,!!e.value.b):new x(e.rs,!0)},k.castMap={string:e=>e,char:e=>{if(1===e.value.length)return new E(e.rs,e.value[0]);throw new Error(`[${v.CAST_ERROR}] Cannot safely cast string of length ${e.value.length} to type char`)},bool:e=>new x(e.rs,!!e.value),complex:e=>new b(e.rs,+e.value),complex_int:e=>new b(e.rs,Math.floor(+e.value)),real:e=>new b(e.rs,+e.value),real_int:e=>new b(e.rs,Math.floor(+e.value)),array:e=>new $(e.rs,e.value.split("").map((t=>new k(e.rs,t)))),set:e=>new A(e.rs,e.value.split("").map((t=>new k(e.rs,t))))},E.castMap={char:e=>e,string:e=>new k(e.rs,String.fromCharCode(e.value)),bool:e=>new x(e.rs,!!e.value),complex:e=>new b(e.rs,e.value),complex_int:e=>new b(e.rs,e.value),real:e=>new b(e.rs,e.value),real_int:e=>new b(e.rs,e.value)},x.castMap={bool:e=>e,complex:e=>new b(e.rs,+e.value),complex_int:e=>new b(e.rs,+e.value),real:e=>new b(e.rs,+e.value),real_int:e=>new b(e.rs,+e.value),string:e=>new k(e.rs,e.value.toString()),char:e=>new E(e.rs,+e.value)},$.castMap={array:e=>e,set:e=>new A(e.rs,e.value),string:e=>new k(e.rs,"["+e.value.map((e=>e.toString())).join(",")+"]"),bool:e=>new x(e.rs,0!==e.value.length),map:e=>{const t=new T(e.rs);return e.value.forEach(((e,r)=>t.value.set(r,e))),t}},A.castMap={set:e=>e,array:e=>new $(e.rs,e.value),string:e=>new k(e.rs,"{"+e.value.map((e=>e.toString())).join(",")+"}"),bool:e=>new x(e.rs,0!==e.value.length),map:e=>0===e.__len__()?new T(e.rs):void 0},T.castMap={map:e=>e,string:e=>new k(e.rs,"{"+Array.from(e.value.entries()).map((e=>e.join(":"))).join(",")+"}"),bool:e=>new x(e.rs,!!e.value),array:e=>new $(e.rs,e.__iter__().map((t=>new $(e.rs,t))))},S.castMap={func:e=>e,string:e=>new k(e.rs,e.toString()),bool:e=>new x(e.rs,!0)},e.exports={Value:_,UndefinedValue:y,NumberValue:b,StringValue:k,CharValue:E,BoolValue:x,ArrayValue:$,SetValue:A,MapValue:T,FunctionRefValue:S,primitiveToValueClass:function e(t,r){if(r instanceof _)return r;if(null==t)return new y(t);if("boolean"==typeof r)return new x(t,r);const i=n.is(r);if(!1!==i)return new b(t,i);if(r instanceof Set)return new A(t,Array.from(r).map((r=>e(t,r))));if(r instanceof Map){let n=new T(rs);return r.forEach(((r,i)=>{n.value.set(i,e(t,r))})),n}if(Array.isArray(r))return new $(t,r.map((r=>e(t,r))));if(r instanceof s){const e=t.getVar(r.name);return e instanceof S?e:new S(this,r)}return new k(t,r)}}},206:e=>{e.exports=()=>({defineFuncs:!0,prompt:">> ",intro:!0,imag:"i",bidmas:!0,multiline:!0,timeExecution:!1})},328:(e,t,r)=>{const n=r(397),{RunspaceBuiltinFunction:i}=r(225),{VariableToken:s,KeywordToken:a}=r(543),{lambertw:l,isPrime:c,LCF:u,primeFactors:h,factorialReal:p,factorial:f,generatePrimes:d,mean:m,variance:w,PMCC:g,gamma:v,wrightomega:_,nextNearest:y,stirling:b,zeta:k,bernoulli:E,random:x}=r(787),{sort:$,numberTypes:A,toBinary:T,fromBinary:S,int_to_base:P,base_to_int:N}=r(89),{types:F,isTypeOverlap:M}=r(880),{FunctionRefValue:R,StringValue:I,Value:O,ArrayValue:B,NumberValue:C,SetValue:V,BoolValue:D,UndefinedValue:L,CharValue:Y,MapValue:U}=r(444),{PI:j,E:z,OMEGA:q,PHI:X,TWO_PI:G,DBL_EPSILON:W}=r(197),H=r(39),{errors:J,errorDesc:K}=r(365),{Fraction:Q}=r(185);e.exports={define:function(e){return e.defineVar("nan",NaN,"Value representing Not A Number"),e.defineVar("inf",1/0,"Value representing Infinity"),e.defineVar("undef",new L(e),"A variable that has not been assigned a value is of type undefined"),e.defineVar("universal_set",new V(e,[]),"Universal set"),e.defineFunc(new i(e,"help",{item:"?any"},(async({item:t})=>{let r="";if(void 0===t)r="help(?s) \t Get help on an argument e.g. function, variable, operator\ncopyright() \t View copyright information\nerror_code(code) \t Return brief help on a given error code\nvars() \t Return array of all variables\noperators() \t Return array of all operators\ntypes() \t Return array of all available types \nnew(type) \t Instantiates a new value of type <type> \nkeywords() \t Return array of all keywords \nimport() \t Import a script relative to import_dir()\nexit() \t Terminate the program";else if(t instanceof s){let e=t.getVar();if(e.value instanceof R){let n=e.value.getFn();void 0===n?t._throwNullRef():r=`${n instanceof i?"built-in":"user-defined"} function ${n.signature()}\n/* @argcount ${n.argMin===n.argMax?n.argMin:isFinite(n.argMax)?`${n.argMin}-${n.argMax}`:n.argMin+"+"}, @about ${n.about()} */`}else r=`let ${t.value}: ${e.value.type()} = ${e.toPrimitive("string")}\n/* @about ${e.desc} */`}else if(t instanceof I&&void 0!==H[t.value]){const e=H[t.value],n=Array.isArray(e.args)?`${e.args.join(" or ")} (${e.args.length} overloads)`:e.args;r=`operator ${t.value} "${e.name}"\n/* @about ${e.desc} (${n} args)${e.unary?" (has unary overload)":""}\n * @precedence ${e.precedence}, @associativity ${e.assoc} */`}else if(t instanceof I&&a.keywords.includes(t.value))r=`keyword "${t.value}"`;else if(t instanceof O){let e=t.toString();r=`string[${e.length}] "${e}"`}else if(e.opts.strict)throw new Error(`[${J.BAD_ARG}] Argument Error: Cannot get help on given argument`);return new I(e,r)}),"Get general help or help on a provided argument")),e.defineFunc(new i(e,"copyright",{},(()=>new I(e,"Copyright (c) 2022 Ruben Saunders.\nAll Right Reserved.")),"View copyright information")),e.defineFunc(new i(e,"del",{obj:"any",key:"?any"},(({obj:e,key:t})=>{const r=void 0===t?e.__del__?.(t):e.castTo("any").__del__?.(t);if(void 0===r)throw new Error(`[${J.DEL}] Argument Error: cannot del() object of type ${e.type()}`);return r}),"attempt to delete given object. If a key is given, attempts to delete that key from the given object.")),e.defineFunc(new i(e,"exit",{c:"?real_int"},(({c:t},r)=>(void 0===t&&(t=new C(e,0)),r.action=-1,r.actionValue=t.toPrimitive("real"),t)),"exit application with given code")),e.defineFunc(new i(e,"signal",{code:"?real_int",value:"?any"},(({code:t,value:r},n)=>(void 0!==t&&(n.action=t.toPrimitive("real_int"),void 0!==r&&(n.actionValue=r)),new C(e,n.action))),"Get/set current evaluation signal")),e.defineFunc(new i(e,"locals",{},((t,r)=>{const n=e.get_process(r.pid).vars,i=Array.from(n[n.length-1].keys()).map((t=>new I(e,t)));return new B(e,i)}),"list all variables in the current scope (local variables)")),e.defineFunc(new i(e,"vars",{},((t,r)=>{const n=new Set,i=e.get_process(r.pid).vars;for(let e=i.length-1;e>=0;e--)i[e].forEach(((e,t)=>{n.has(e)||n.add(t)}));return new B(e,Array.from(n).map((t=>new I(e,t))))}),"list all defined variables in the process")),e.defineFunc(new i(e,"globals",{},(()=>{const t=Array.from(e._globals.keys()).map((t=>new I(e,t)));return new B(e,t)}),"list all variables in the global scope. These cannot be deleted.")),e.defineFunc(new i(e,"labels",{},((t,r)=>{const n=e.get_process(r.pid).blocks.get(r.blockID).getAllLabels();return new B(e,Array.from(n.keys()).map((t=>new I(e,t))))}),"list all addressable labels")),e.defineFunc(new i(e,"scope_push",{},((t,r)=>(e.pushScope(r.pid),new C(e,e.get_process(r.pid).vars.length))),"Force a creation of a new lexical scope")),e.defineFunc(new i(e,"scope_pop",{},((t,r)=>{const n=e.get_process(r.pid).vars.length;return n>1?(e.popScope(r.pid),new C(e,n-1)):new C(e,n)}),"Force the destruction of the current local scope (will not pop local#0)")),e.defineFunc(new i(e,"keywords",{},(()=>new B(e,a.keywords.map((t=>new I(e,t))))),"list all keywords")),e.defineFunc(new i(e,"operators",{},(()=>new B(e,Object.keys(H).map((t=>new I(e,t))))),"return array all available operators")),e.defineFunc(new i(e,"types",{},(()=>new B(e,Array.from(F).map((t=>new I(e,t))))),"return array of all valid types")),e.defineFunc(new i(e,"cast",{o:"any",type:"string"},(({o:e,type:t})=>e.castTo(t.toString())),"attempt a direct cast from object <o> to type <type>")),e.defineFunc(new i(e,"type",{o:"any"},(({o:t})=>new I(e,t.type())),"returns the type of object <o>")),e.defineFunc(new i(e,"type_overlap",{t1:"string",t2:"string"},(({t1:t,t2:r})=>new D(e,M(t.toString(),r.toString()))),"does type t1 overlap with type t2?")),e.defineFunc(new i(e,"complex",{a:"real",b:"real"},(({a:t,b:r})=>new C(e,new n(t,r))),"create a complex number")),e.defineFunc(new i(e,"void",{o:"any"},(({o:t})=>new L(e)),"throws away given argument - returns undefined")),e.defineFunc(new i(e,"new",{t:"string"},(({t})=>{if((t=t.castTo("any"))instanceof U)return t.createInstance();{t=t.toString();const r=O.__new__?.(e,t);if(void 0===r)throw new Error(`[${J.BAD_ARG}] Argument Error: Type ${t} cannot be initialised`);return r}}),"create new value of type <t>. If <t> is a map, creates new instance (doesn't call _Construct)")),e.defineFunc(new i(e,"isinstance",{o:"any",t:"?any"},(({o:t,t:r})=>{if(t=t.castTo("any"),void 0===r)return new D(e,t instanceof U&&void 0!==t.instanceOf);r=r.castTo("any");let n=t instanceof U&&r instanceof U?t.isInstanceOf(r):t.type()===r.type();return new D(e,n)}),"return if <o> is an instance of, or inherits from, <t>. If <o> and <t> are not maps, compares types. If only one argument provided, returns if <o> is an instance of anything.")),e.defineFunc(new i(e,"inherit",{inheritor:"map",types:{type:"map",ellipse:!0}},(({inheritor:e,types:t})=>{if(!((e=e.castTo("any"))instanceof U))throw new Error(`[${J.BAD_ARG}] Argument Error: expected inheritor to be of type map, got type ${e.type()}`);t=t.toPrimitive("array").map((e=>e.castTo("any")));for(let e of t)if(!(e instanceof U))throw new Error(`[${J.BAD_ARG}] Argument Error: expected types to be array of maps, got type ${e.type()}`);for(let r of t)e.inheritFrom.add(r);return e}),"<inheritor> now inherits from <types>")),e.defineFunc(new i(e,"array",{len:"?real_int",val:"?any"},(async({len:t,val:r},n)=>{if(void 0===t)return new B(e);if(void 0===r)return new B(e,Array.from({length:t.toPrimitive("real_int")}).fill(e.UNDEFINED));if("func"===(r=r.castTo("any")).type()){const i=Array.from({length:t.toPrimitive("real_int")});for(let t=0;t<i.length;t++)i[t]=await r.value.call(n,[new C(e,t)]);return new B(e,i)}return new B(e,Array.from({length:t.toPrimitive("real_int")}).fill(r))}),"create and return a new array of length <len=1>. Fill with value <val=undef>, of call <val>(index)")),e.defineFunc(new i(e,"array2d",{cols:"real_int",rows:"real_int",val:"?any"},(async({cols:t,rows:r,val:n},i)=>(n=n?n.castTo("any"):e.UNDEFINED,t=t.toPrimitive("real_int"),r=r.toPrimitive("real_int"),"func"===n.type()?new B(e,await Promise.all(Array.from({length:t},(async()=>new B(e,await Promise.all(Array.from({length:r},(()=>n.value.call(i))))))))):new B(e,Array.from({length:t},(()=>new B(e,Array.from({length:r}).fill(n))))))),"create and return a 2D new array with <cols> cols and <rows> rows, and fill with <val=undef> (may be a function)")),e.defineFunc(new i(e,"copy",{o:"any"},(({o:e})=>{const t=e.castTo("any").__copy__?.();if(void 0===t)throw new Error(`[${J.CANT_COPY}] Type Error: Type ${e.type()} cannot be copied`);return t}),"Return a copy of object <o>")),e.defineFunc(new i(e,"call",{fn:"string",args:{type:"array",optional:!0,ellipse:!0}},(async({fn:e,args:t},r)=>(e=e.castTo("any").getFn(),await e.call(r,t?t.toPrimitive("array").map((e=>e.castTo("any"))):[]))),"Call function <fn> with <args> provided as arguments")),e.defineFunc(new i(e,"chr",{n:"real_int"},(({n:t})=>new Y(e,String.fromCharCode(t.toPrimitive("real")))),"return character with ASCII code <n>")),e.defineFunc(new i(e,"ord",{chr:"string"},(({chr:t})=>new C(e,t.toString().charCodeAt(0))),"return character code of <chr>")),e.defineFunc(new i(e,"isdefined",{name:"string"},(({name:t},r)=>{let n=e.getVar(t.toString(),r.pid);return new D(e,n)}),"returns boolean indicating if name <name> is defined and accessable")),e.defineFunc(new i(e,"getvar",{name:"string"},(({name:t},r)=>{const n=e.getVar(t.toString(),r.pid);return n?n.castTo("any"):e.UNDEFINED}),"get variable with name <name> (or undef)")),e.defineFunc(new i(e,"setvar",{name:"string",value:"?any"},(({name:t,value:r},n)=>(t=t.toString(),r=r.castTo("any"),e.defineVar(t,r,void 0,n.pid),r)),"sets/defines local variable with name <name>")),e.defineFunc(new i(e,"range",{a:"real",b:"?real",c:"?real"},(({a:t,b:r,c:n})=>{let i,s,o;if(void 0===r?(i=0,s=t.toPrimitive("real"),o=1):void 0===n?(i=t.toPrimitive("real"),s=r.toPrimitive("real"),o=1):(i=t.toPrimitive("real"),s=r.toPrimitive("real"),o=n.toPrimitive("real")),isNaN(i)||isNaN(s)||isNaN(o)||!isFinite(i)||!isFinite(s)||!isFinite(o)||Math.sign(s-i)!==Math.sign(o))throw new Error(`[${J.BAD_ARG}] Argument Error: Argument type Argument Error: range is infinite given arguments`);const a=[];for(let t=i;t<s;t+=o)a.push(new C(e,t));return new B(e,a)}),"Return array populated with numbers between <a>-<b> step <c>. 1 arg=range(0,<a>,1); 2 args=range(<a>,<b>,1); 3 args=range(<a>,<b>,<c>)")),e.defineFunc(new i(e,"len",{o:"any",len:"?real_int"},(({o:t,len:r})=>{let n;if(t=t.castTo("any"),r){const e=r.toPrimitive("real_int");if(e<0||isNaN(e)||!isFinite(e))throw new Error(`[${J.BAD_ARG}] Argument Error: invalid length ${r}`);n=t.__len__?.(e)}else n=t.__len__?.();if(void 0===n)throw new Error(`[${J.BAD_ARG}] Argument Error: argument of type ${t.type()} has no len()`);return new C(e,void 0===n?NaN:n)}),"return length of argument or set new length")),e.defineFunc(new i(e,"to_json",{o:"any"},(({o:t})=>{const r=t.castTo("any").__toJson__?.();if(void 0===r)throw new Error(`[${J.BAD_ARG}] Argument Error: argument of type ${t.type()} cannot be converted to JSON`);return new I(e,r)}),"return JSON representation of object")),e.defineFunc(new i(e,"max",{o:"any"},(({o:e})=>{const t=e.castTo("any").__max__?.();if(void 0===t)throw new Error(`[${J.BAD_ARG}] Argument Error: argument of type ${e.type()} has no max()`);return t}),"return maximum value of the argument")),e.defineFunc(new i(e,"min",{o:"any"},(({o:e})=>{const t=e.castTo("any").__min__?.();if(void 0===t)throw new Error(`[${J.BAD_ARG}] Argument Error: argument of type ${e.type()} has no min()`);return t}),"return minimum value of the argument")),e.defineFunc(new i(e,"abs",{o:"any"},(({o:t})=>{const r=t.castTo("any").__abs__?.();if(void 0===r)throw new Error(`[${J.BAD_ARG}] Argument Error: argument of type ${t.type()} has no abs()`);return new C(e,void 0===r?NaN:r)}),"return length of argument")),e.defineFunc(new i(e,"getprop",{arg:"any",key:"any"},(({arg:e,key:t})=>{if("function"!=typeof(e=e.castTo("any")).__get__)throw new Error(`[${J.BAD_ARG}] Argument Error: cannot get property of type ${e.type()}`);return e.__get__(t)}),"get property <key> in <arg> (same as <arg>[<key>])")),e.defineFunc(new i(e,"setprop",{arg:"any",key:"any",value:"any"},(({arg:e,key:t,value:r})=>{if(e=e.castTo("any"),t=t.castTo("any"),r=r.castTo("any"),"function"!=typeof e.__set__)throw new Error(`[${J.BAD_ARG}] Argument Error: cannot set property of type ${e.type()}`);return e.__set__(t,r)}),"set property <key> in <arr> to <item> (same as <arg>[<key>] = <value>)")),e.defineFunc(new i(e,"push",{arr:"array",item:"any"},(({arr:t,item:r})=>{if(t=t.castTo("any"),r=r.castTo("any"),t instanceof B)return new C(e,t.value.push(r));if(t instanceof V)return t.run((()=>t.value.push(r))),new C(e,t.value.length);throw new Error(`[${J.TYPE_ERROR}] Type Error: expected collection, got ${t.type()}`)}),"push item <item> to array <arr>")),e.defineFunc(new i(e,"pop",{arr:"array"},(({arr:e})=>{if((e=e.castTo("any"))instanceof B||e instanceof V)return e.value.pop();throw new Error(`[${J.TYPE_ERROR}] Type Error: expected array, got ${e.type()}`)}),"pop item from array <arr>")),e.defineFunc(new i(e,"reverse",{arg:"any"},(({arg:e})=>{let t=(e=e.castTo("any")).__reverse__?.();if(void 0===t)throw new Error(`[${J.BAD_ARG}] Argument Error: cannot reverse() type ${e.type()}`);return t}),"reverse argument <arg>")),e.defineFunc(new i(e,"sort",{arr:"array"},(({arr:t})=>new B(e,$(t.toPrimitive("array").map(((e,t)=>{if("real"!==e.type())throw new Error(`[${J.TYPE_ERROR}]  Type Error: expected array of real numbers, got ${e.type()} at index ${t}`);return e.toPrimitive("real")}))).map((t=>new C(e,t))))),"sort array numerically")),e.defineFunc(new i(e,"filter",{arr:"array",fn:"func"},(async({arr:t,fn:r},n)=>{const i=[];if(1!==(r=r.castTo("func").getFn()).argMin&&2!==r.argMin)throw new Error(`[${J.BAD_ARG}] Argument Error: func must accept at least 1 or 2 arguments, got function with ${r.argMin} arguments`);t=t.toPrimitive("array");for(let s=0;s<t.length;s++){let o=1===r.argMin?[t[s]]:[t[s],new C(e,s)];(await r.call(n,o)).toPrimitive("bool")&&i.push(t[s])}return new B(e,i)}),"Remove all values from arr for which fn(value, ?index) is false")),e.defineFunc(new i(e,"map",{arr:"array",fn:"func"},(async({arr:t,fn:r},n)=>{r=r.castTo("func").getFn();let i=t.toPrimitive("array");const s=[];if(0===r.argMin)for(let e=0;e<i.length;e++)s.push(await r.call(n,[]));else if(1===r.argMin)for(let e=0;e<i.length;e++)s.push(await r.call(n,[i[e]]));else if(2===r.argMin)for(let t=0;t<i.length;t++)s.push(await r.call(n,[i[t],new C(e,t)]));else{if(3!==r.argMin)throw new Error(`${J.BAD_ARG} Argument Error: func must take 0-4 arguments, got ${r.signature()}`);{let o=t.getVar().value.__copy__();for(let t=0;t<i.length;t++)s.push(await r.call(n,[i[t],new C(e,t),o]))}}return new B(e,s)}),"Apply func to each item in array, push return value to new array and return new array. Func -> (?item, ?index, ?array)")),e.defineFunc(new i(e,"foreach",{arr:"array",fn:"func"},(async({arr:t,fn:r},n)=>{r=r.castTo("func").getFn();let i=t.toPrimitive("array");if(0===r.argMin)for(let e=0;e<i.length;e++)await r.call(n,[]);else if(1===r.argMin)for(let e=0;e<i.length;e++)await r.call(n,[i[e]]);else if(2===r.argMin)for(let t=0;t<i.length;t++)await r.call(n,[i[t],new C(e,t)]);else{if(3!==r.argMin)throw new Error(`${J.BAD_ARG} Argument Error: func must take 0-4 arguments, got ${r.signature()}`);{let s=t.getVar().value.__copy__();for(let t=0;t<i.length;t++)await r.call(n,[i[t],new C(e,t),s])}}return new L(e)}),"Apply func to each item in array. Func -> (?item, ?index, ?array)")),e.defineFunc(new i(e,"reduce",{arr:"array",fn:"func",initial:"?any"},(async({arr:t,fn:r,initial:n},i)=>{let s=n?n.castTo("any"):new C(e,0);if(2!==(r=r.castTo("func").getFn()).argMin&&3!==r.argMin)throw new Error(`[${J.BAD_ARG}] Argument Error: func must have 2 or 3 arguments, got function with ${r.argMin} arguments`);t=t.toPrimitive("array");for(let n=0;n<t.length;n++){let o=2===r.argMin?[s,t[n]]:[s,t[n],new C(e,n)];s=await r.call(i,o)}return s}),"Reduce array to single value via func(acc, current, ?index). Initially, acc = initial or 0")),e.defineFunc(new i(e,"find",{obj:"any",item:"any"},(({obj:e,item:t})=>{t=t.castTo("any");let r=(e=e.castTo("any")).__find__?.(t);if(void 0===r)throw new Error(`[${J.BAD_ARG}] Argument Error: cannot search type ${o.type()}`);return r}),"Find <item> in <o>. Collections: return index of <item> or -1. Map: return key of item with value <item> or undefined.")),e.defineFunc(new i(e,"fill",{array:"array",item:"any"},(async({array:t,item:r},n)=>{if(!(t instanceof s&&"array"===t.type()))throw new Error(`[${J.BAD_ARG}] Argument Error: expected variable of type array for <array>`);r=r.castTo("any");let i=t.getVar().value,o=i.value.length;if("func"===r.type()){let t=r.value;if(0===t.argMin)for(let e=0;e<o;e++)i.value[e]=await t.call(n,[]);else{if(1!==t.argMin)throw new Error(`[${J.BAD_ARG}] Argument Error: func <item> has invalid argument count. Expected 0-1, got ${t.argMin}`);for(let r=0;r<o;r++)i.value[r]=await t.call(n,[new C(e,r)])}}else for(let e=0;e<o;e++)i.value[e]=r;return t}),"Fills referenced array <array> with static <item> or, if <item> is a func, calls <item>(?index, ?array) for each item")),e.defineFunc(new i(e,"base",{arg:"string",from:"real_int",to:"real_int"},(({arg:t,from:r,to:n})=>(r=r.toPrimitive("real_int"),n=n.toPrimitive("real_int"),new I(e,P(N(t.toString(),r),n)))),"Convert <arg> from base <from> to base <to>")),e.defineFunc(new i(e,"eval",{str:"string",pid:"?real_int"},(async({str:t,pid:r},n)=>{r=void 0===r?n.pid:r.toPrimitive("real_int");let i=e.get_process(r);if(void 0===i)throw new Error(`[${J.BAD_ARG}] Argument Error: cannot execute code on unexistant process PID=${r}`);if(i.imported_files.push("<eval>"),await e.exec(r,t.toString()),i.imported_files.pop(),2===i.state)throw i.stateValue;return i.stateValue.ret??e.UNDEFINED}),"evaluate an input")),e.defineFunc(new i(e,"iif",{cond:"bool",ifTrue:"any",ifFalse:"?any"},(({cond:t,ifTrue:r,ifFalse:n})=>t.toPrimitive("bool")?r:void 0===n?new D(e,!1):n),"Inline IF: If <cond> is truthy, return <ifTrue> else return <ifFalse> or false")),e.defineFunc(new i(e,"import",{file:"string"},(async({file:t},r)=>await e.import(r.pid,t.toString())),"Import <file> - see README.md for more details")),e.defineFunc(new i(e,"import_stack",{},((t,r)=>e.generateArray(e.get_process(r.pid).import_stack.map((t=>new I(e,t))))),"Return import stack")),e.defineFunc(new i(e,"imported_files",{},((t,r)=>e.generateArray(e.get_process(r.pid).imported_files.map((t=>new I(e,t))))),"Return imported files in current import chain")),e.defineFunc(new i(e,"error_code",{code:"string"},(({code:t})=>{if((t=t.toPrimitive("string"))in K)return new I(e,K[t]);throw new Error(`[${J.BAD_ARG}] Argument Error: no such error code [${t}]`)}),"Return brief description of an error code (the [...] in an error message)")),e.defineFunc(new i(e,"ucase",{str:"string"},(({str:t})=>new I(e,t.toString().toUpperCase())),"String: to upper case")),e.defineFunc(new i(e,"lcase",{str:"string"},(({str:t})=>new I(e,t.toString().toLowerCase())),"String: to upper case")),e.defineFunc(new i(e,"tcase",{str:"string"},(({str:t})=>new I(e,t.toString().split(" ").map((e=>e[0].toUpperCase()+e.substr(1).toLowerCase())).join(" "))),"String: to title case")),e.defineFunc(new i(e,"replace",{str:"string",search:"string",replace:"string",once:"?bool"},(({str:t,search:r,replace:n,once:i})=>new I(e,t.toString().replace(!i||i&&!i.toPrimitive("bool")?new RegExp(r.toString(),"g"):r.toString(),n.toString()))),"String: replace one/all instances of <search> with <replace>")),e.defineFunc(new i(e,"substr",{str:"string",index:"real_int",length:"?real_int"},(({str:t,index:r,length:n})=>new I(e,t.toString().substr(r.toPrimitive("real_int"),void 0===n?void 0:n.toPrimitive("real_int")))),"String: return section of string starting at <index> and extending <length> chars")),e.defineFunc(new i(e,"split",{str:"string",splitter:"?string"},(({str:t,splitter:r})=>new B(e,t.toString().split(void 0===r?"":r.toString()).map((t=>new I(e,t))))),"String: split string by <splitter> to form an array")),e.defineFunc(new i(e,"join",{arr:"array",seperator:"?string"},(({arr:t,seperator:r})=>new I(e,t.toPrimitive("array").map((e=>e.toString())).join(r??""))),"String: Join elements in an array by <seperator> to form a string")),e.defineFunc(new i(e,"numbertypes",{},(()=>new B(e,A.map((t=>new I(e,t))))),"Return array of all numerical types")),e.defineFunc(new i(e,"tobinary",{n:"real",t:"?string"},(({n:t,t:r})=>{if(r=r?r.toPrimitive("string"):"float64",!A.includes(r))throw new Error(`[${J.BAD_ARG}] Argument Error: invalid numeric type '${r}'`);t=t.toPrimitive("real");let n=T(t,r);return new I(e,n)}),"Given a number, return binary representation as type <t> (default: float64. See numbertypes() for list of numerical types)")),e.defineFunc(new i(e,"frombinary",{bin:"string",t:"?string"},(({bin:t,t:r})=>{if(r=r?r.toPrimitive("string"):"float64",!A.includes(r))throw new Error(`[${J.BAD_ARG}] Argument Error: invalid numeric type '${r}'`);t=t.toPrimitive("string");let n=S(t,r);return new C(e,n)}),"Given binary, return number representation as type <t> (default: float64. See numbertypes() for list of numerical types)")),e.defineFunc(new i(e,"fnanal",{fn:"func"},(({fn:t})=>{t=t.getVar().value.value;let r=new U(e);r.value.set("name",new I(e,t.name)),r.value.set("argMin",new C(e,t.argMin)),r.value.set("argMax",new C(e,t.argMax));const n=[];for(let[r,i]of t.args){let t=new U(e);t.value.set("name",new I(e,r)),t.value.set("pass",new I(e,i.pass)),t.value.set("type",new I(e,i.type)),t.value.set("optional",new D(e,i.optional)),t.value.set("ellipse",new D(e,i.ellipse)),n.push(t)}return r.value.set("args",new B(e,n)),r}),"Return map analysis of provided function")),e.defineFunc(new i(e,"fnsigmatch",{a:"func",b:"func"},(({a:t,b:r})=>(t=t.getVar().value.value,r=r.getVar().value.value,new D(e,t.signatureMatch(r)))),"Return whether <a> matches <b>s signature")),e},defineVars:function(e){e.defineVar("DBL_EPSILON",W,"smallest such that 1.0+DBL_EPSILON != 1.0"),e.defineVar("pi",j,"pi is equal to the circumference of any circle divided by its diameter"),e.defineVar("e",z,"Euler's constant"),e.defineVar("omega",q,"Principle solution to xe^x = 1 (= W(1))"),e.defineVar("phi",X,"Phi, the golden ratio, approx (1 + √5)/2"),e.defineVar("tau",G,"A constant representing the ratio between circumference and radius of a circle"),e.defineVar(n.imagLetter,new n(0,1),"√(-1)"),e.defineVar("ln2",Math.LN2,"Natural logarithm of 2"),e.defineVar("ln10",Math.LN10,"Natural logarithm of 10"),e.defineVar("log2e",Math.LOG2E,"Base-2 logarithm of e"),e.defineVar("log10e",Math.LOG10E,"Base-10 logarithm of e"),e.defineVar("sqrt1_2",Math.SQRT1_2,"Square root of 0.5"),e.defineVar("sqrt2",Math.SQRT2,"Square root of 2")},defineFuncs:function(e){e.defineFunc(new i(e,"arccos",{z:"complex"},(({z:t})=>new C(e,n.arccos(t.toPrimitive("complex")))),"return arccosine of z")),e.defineFunc(new i(e,"arccosh",{z:"complex"},(({z:t})=>new C(e,n.arccosh(t.toPrimitive("complex")))),"return hyperbolic arccosine of z")),e.defineFunc(new i(e,"arcsin",{z:"complex"},(({z:t})=>new C(e,n.arcsin(t.toPrimitive("complex")))),"return arcsine of z")),e.defineFunc(new i(e,"arcsinh",{z:"complex"},(({z:t})=>new C(e,n.arcsinh(t.toPrimitive("complex")))),"return hyperbolic arcsine of z")),e.defineFunc(new i(e,"arctan",{z:"complex"},(({z:t})=>new C(e,n.arctan(t.toPrimitive("complex")))),"return arctangent of z")),e.defineFunc(new i(e,"arctanh",{z:"complex"},(({z:t})=>new C(e,n.arctanh(t.toPrimitive("complex")))),"return hyperbolic arctangent of z")),e.defineFunc(new i(e,"arg",{z:"complex"},(({z:t})=>new C(e,t.toPrimitive("complex").arg())),"return the argument of z")),e.defineFunc(new i(e,"cbrt",{z:"complex"},(({z:t})=>new C(e,n.cbrt(t.toPrimitive("complex")))),"return cube root of x")),e.defineFunc(new i(e,"ceil",{z:"complex"},(({z:t})=>new C(e,n.ceil(t.toPrimitive("complex")))),"round x up to the nearest integer")),e.defineFunc(new i(e,"conj",{z:"complex"},(({z:t})=>new C(e,t.toPrimitive("complex").conjugate())),"return z* (the configate) of z")),e.defineFunc(new i(e,"cos",{z:"complex"},(({z:t})=>new C(e,n.cos(t.toPrimitive("complex")))),"return cosine of x")),e.defineFunc(new i(e,"cosh",{z:"complex"},(({z:t})=>new C(e,n.cosh(t.toPrimitive("complex")))),"return hyperbolic cosine of x")),e.defineFunc(new i(e,"time",{msOffset:"?real_int"},(({msOffset:t})=>new C(e,(t?new Date(t.toPrimitive("real_int")):new Date).getTime())),"returns the number of milliseconds elapsed since January 1, 1970 00:00:00 UTC")),e.defineFunc(new i(e,"date",{arg:"?any"},(({arg:t})=>{let r,n=t?.type();if(void 0===t)r=new Date;else if("real"===n)r=new Date(t.toPrimitive("real_int"));else{if("string"!==n)throw new Error(`[${J.BAD_ARG}] Argument Error: cannot construct date from type ${n}`);r=new Date(t.toPrimitive("string"))}return new I(e,r.toString())}),"returns date string constructed from <arg>")),e.defineFunc(new i(e,"exp",{z:"complex"},(({z:t})=>new C(e,n.exp(t.toPrimitive("complex")))),"return e^x")),e.defineFunc(new i(e,"floor",{z:"complex"},(({z:t})=>new C(e,n.floor(t.toPrimitive("complex")))),"round x down to the nearest integer")),e.defineFunc(new i(e,"isnan",{z:"complex"},(({z:t})=>new D(e,n.isNaN(t.toPrimitive("complex")))),"return 0 or 1 depending on is x is NaN")),e.defineFunc(new i(e,"isinf",{z:"complex"},(({z:t})=>new D(e,!n.isFinite(t.toPrimitive("complex")))),"return 0 or 1 depending on is x is infinite")),e.defineFunc(new i(e,"isprime",{x:"real"},(({x:t})=>new D(e,c(t.toPrimitive("real")))),"return 0 or 1 depending on if x is prime")),e.defineFunc(new i(e,"primes",{limit:"real_int"},(({limit:t})=>new B(e,d(t.toPrimitive("real")))),"generate list of primes 0..limit")),e.defineFunc(new i(e,"factors",{x:"real"},(({x:t})=>new B(e,h(t.toPrimitive("real")).map((t=>new C(e,t))))),"return prime factors of x")),e.defineFunc(new i(e,"factorial",{z:"complex"},(({z:t})=>new C(e,f(t.toPrimitive("complex")))),"calculate the factorial of x using the Gamma function")),e.defineFunc(new i(e,"factorialReal",{x:"real_int"},(({x:t})=>new C(e,p(t.toPrimitive("real")))),"calculate the factorial of x using the common algorithm")),e.defineFunc(new i(e,"ln",{z:"complex"},(({z:t})=>new C(e,n.log(t.toPrimitive("complex")))),"calculate the natural logarithm of x")),e.defineFunc(new i(e,"log",{a:"complex",b:"?complex"},(({a:t,b:r})=>new C(e,void 0===r?n.div(n.log(t.toPrimitive("complex")),Math.LN10):n.div(n.log(r.toPrimitive("complex")),n.log(t.toPrimitive("complex"))))),"return log base <a> of <b>. If b is not provided, return log base 10 of <a>")),e.defineFunc(new i(e,"lcf",{a:"real",b:"real"},(({a:t,b:r})=>new C(e,u(t.toPrimitive("real"),r.toPrimitive("real")))),"return the lowest common factor of a and b")),e.defineFunc(new i(e,"mean",{arr:"array"},(({arr:t})=>new C(e,m(t.toPrimitive("array").map((e=>e.toPrimitive("real")))))),"calculate mean value in an array")),e.defineFunc(new i(e,"PMCC",{x:"array",y:"array"},(({x:t,y:r})=>new C(e,g(t.toPrimitive("array").map((e=>e.toPrimitive("real"))),r.toPrimitive("array").map((e=>e.toPrimitive("real")))))),"Calculate the Product Moment Correlation Coefficient between two data sets")),e.defineFunc(new i(e,"variance",{arr:"array"},(({arr:t})=>new C(e,w(t.toPrimitive("array").map((e=>e.toPrimitive("real")))))),"calculate variance in a dataset")),e.defineFunc(new i(e,"random",{a:"?real",b:"?real"},(({a:t,b:r})=>(void 0!==t&&(t=t.toPrimitive("real")),void 0!==r&&(r=r.toPrimitive("real")),new C(e,x(t,r)))),"return a pseudo-random decimal number. Range: 0 arguments: 0-1. 1 argument: 0-a. 2 arguments: a-b")),e.defineFunc(new i(e,"nPr",{n:"real_int",r:"real_int"},(({n:t,r})=>{if(t=t.toPrimitive("real"),(r=r.toPrimitive("real"))>t)throw new Error(`[${J.BAD_ARG}] Argument Error: invalid argument size relationship: n=${t} and r=${r}`);return new C(e,f(t)/f(t-r))}),"Return the probability of selecting an ordered set of <r> objects from a group of <n> number of objects")),e.defineFunc(new i(e,"nCr",{n:"real_int",r:"real_int"},(({n:t,r})=>{if(t=t.toPrimitive("real"),(r=r.toPrimitive("real"))>t)throw new Error(`[${J.BAD_ARG}] Argument Error: invalid argument size relationship: n=${t} and r=${r}`);return new C(e,f(t)/(f(r)*f(t-r)))}),"Represents the selection of objects from a group of objects where order of objects does not matter")),e.defineFunc(new i(e,"round",{x:"complex",dp:"?real_int"},(({x:t,dp:r})=>(t=t.toPrimitive("complex"),new C(e,void 0===r?n.round(t):n.roundDp(t,r.toPrimitive("real"))))),"round x to the nearest integer, or to <dp> decimal places")),e.defineFunc(new i(e,"Re",{z:"complex"},(({z:t})=>new C(e,t.toPrimitive("complex").a)),"return real component of z")),e.defineFunc(new i(e,"Im",{z:"complex"},(({z:t})=>new C(e,t.toPrimitive("complex").b)),"return imaginary component of z")),e.defineFunc(new i(e,"sin",{z:"complex"},(({z:t})=>new C(e,n.sin(t.toPrimitive("complex")))),"return sine of z")),e.defineFunc(new i(e,"sinh",{z:"complex"},(({z:t})=>new C(e,n.sinh(t.toPrimitive("complex")))),"return hyperbolic sine of z")),e.defineFunc(new i(e,"sqrt",{z:"complex"},(({z:t})=>new C(e,n.sqrt(t.toPrimitive("complex")))),"return square root of z")),e.defineFunc(new i(e,"tan",{z:"complex"},(({z:t})=>new C(e,n.tan(t.toPrimitive("complex")))),"return tangent of z")),e.defineFunc(new i(e,"tanh",{z:"complex"},(({z:t})=>new C(e,n.tanh(t.toPrimitive("complex")))),"return hyperbolic tangent of z")),e.defineFunc(new i(e,"lambertw",{z:"complex",k:"?real",tol:"?real"},(({z:t,k:r,tol:n})=>new C(e,l(t.toPrimitive("complex"),r?.toPrimitive("real"),n?.toPrimitive("real")))),"return approximation of the Lambert W function at <k> branch with <tol> tolerance")),e.defineFunc(new i(e,"wrightomega",{z:"complex"},(({z:t})=>new C(e,_(t.toPrimitive("complex")))),"return approximation of the Wright Omega function")),e.defineFunc(new i(e,"gamma",{z:"complex"},(({z:t})=>new C(e,v(t.toPrimitive("complex")))),"Return the gamma function at z")),e.defineFunc(new i(e,"zeta",{x:"real",q:"?real"},(({x:t,q:r})=>new C(e,k(t.toPrimitive("real"),r?.toPrimitive("real")))),"return approximation of the Zeta function of <x>")),e.defineFunc(new i(e,"bernoulli",{n:"real"},(({n:t})=>new C(e,E(t.toPrimitive("real")))),"return the nth Bernoulli number")),e.defineFunc(new i(e,"stirling",{z:"complex"},(({z:t})=>new C(e,b(t.toPrimitive("complex")))),"Return Stirling's Approximation at z")),e.defineFunc(new i(e,"nextNearest",{n:"real",next:"real"},(({n:t,next:r})=>new C(e,y(t.toPrimitive("real"),r.toPrimitive("real")))),"Return the next representable double from value <n> towards <next>")),e.defineFunc(new i(e,"sleep",{ms:"real_int"},(({ms:e})=>new Promise((t=>setTimeout((()=>t(e)),e.toPrimitive("real_int"))))),"Suspend execution for <ms> milliseconds (1000ms = 1s)")),e.defineFunc(new i(e,"pause",{},(()=>new Promise((t=>setImmediate((()=>t(e.UNDEFINED)))))),"Suspend execution until next event loop cycle")),e.defineFunc(new i(e,"ref",{a:"any",b:"any"},(({a:e,b:t})=>{if(!(e instanceof s))throw new Error(`[${J.BAD_ARG}] Argument Error: a: expected symbol, got ${e.type()}`);if(!(t instanceof s))throw new Error(`[${J.BAD_ARG}] Argument Error: b: expected symbol, got ${t.type()}`);return e.getVar().refFor=t.getVar(),e}),"Place a reference to variable b in variable a (i.e. changing a = changing b)")),e.defineFunc(new i(e,"unref",{a:"any"},(({a:e})=>{if(!(e instanceof s))throw new Error(`[${J.BAD_ARG}] Argument Error: a: expected symbol, got ${e.type()}`);return e.getVar().refFor=void 0,e}),"Remove reference from <a> (<a> is no longer acting as a reference)")),e.defineFunc(new i(e,"getref",{name:"string"},(({name:t})=>{if(t instanceof s){let r=t.getVar().refFor;return r?new I(e,r.name):e.UNDEFINED}throw new Error(`[${J.BAD_ARG}] Argument Error: type ${t.type()} is not a valid reference type (expected symbol)`)}),"Return symbol that <name> is a reference to (or undef)")),e.defineFunc(new i(e,"strformat",{str:"string",values:{ellipse:1}},(({str:e,values:t})=>e.castTo("string").format(t.toPrimitive("array"))),"Return formatted string")),e.defineFunc(new i(e,"nformat",{n:"complex",region:"?string"},(({n:t,region:r})=>new I(e,t.toPrimitive("complex").toLocaleString(r?r.toPrimitive("string"):"en-GB"))),"Return formatted number string")),e.defineFunc(new i(e,"expform",{z:"complex",fdigits:"?real_int"},(({z:t,fdigits:r})=>new I(e,t.toPrimitive("complex").toExponential(r?r.toPrimitive("real_int"):void 0))),"Return complex number in exponential form, with <fdigits> fractional digits")),e.defineFunc(new i(e,"tofrac",{num:"real",improper:"?bool"},(({num:t,improper:r})=>new I(e,new Q(t.toPrimitive("real")).toString(!r||r.toPrimitive("bool")))),"Convert a real number to a fraction (string)")),e.defineFunc(new i(e,"fromfrac",{frac:"string"},(({frac:t})=>new C(e,new Q(t.toPrimitive("string")).toNumber())),"Convert fraction string to a number")),e.defineFunc(new i(e,"quadratic",{a:"complex",b:"complex",c:"complex"},(({a:t,b:r,c:i})=>{t=t.toPrimitive("complex"),r=r.toPrimitive("complex"),i=i.toPrimitive("complex");let s=n.sqrt(n.pow(r,2).sub(n.mult(4,t).mult(i))),o=n.mult(r,-1),a=n.mult(t,2);return new B(e,[new C(e,n.add(o,s).div(a)),new C(e,n.sub(o,s).div(a))])}),"Solve quadratic in form ax^2 + bx + c")),e.defineFunc(new i(e,"zroots",{n:"real_int",r:"complex"},(({n:t,r})=>{t=t.toPrimitive("real_int"),r=r.toPrimitive("complex");const i=[],s=n.mult(2,Math.PI),o=e=>n.add(Math.PI,n.mult(s,e)).div(t);let a=1,l=0;for(i.push(o(0));;){let e=o(l?-a:a);if(i.some((t=>t===e))||i.push(e),i.length>t)break;1===l&&a++,l^=1}const c=Math.pow(r,n.div(1,t)),u=new n(0,1),h=i.map((e=>n.add(n.cos(e).mult(c),n.sin(e).mult(c).mult(u))));return new B(e,h.map((t=>new C(e,t))))}),"Returns array of roots for z**n = r")),e.defineFunc(new i(e,"pascal",{r:"real_int"},(({r:t})=>{t=parseInt(t.toPrimitive("real"));let r=Array.from({length:t-1}).map(((e,t,r)=>p(r.length)/(p(t)*p(r.length-t)))).map((e=>isFinite(e)?e:1)).concat([1]);return new B(e,r.map((t=>new C(e,Math.round(t)))))}),"Return array of Pascal coefficients for <r>th for of Pascal's Triangle"))}}},397:e=>{class t{constructor(e=0,t=0){this.a=+e,this.b=+t}isReal(){return 0===this.b}add(e){return e=t.assert(e),this.a+=e.a,this.b+=e.b,this}sub(e){return e=t.assert(e),this.a-=e.a,this.b-=e.b,this}mult(e){e=t.assert(e);let r=this.a*e.a-this.b*e.b,n=this.a*e.b+this.b*e.a;return this.a=r,this.b=n,this}mag(e){if(void 0===e)return Math.sqrt(Math.pow(this.a,2)+Math.pow(this.b,2));let t=this.arg();return this.a=e*Math.cos(t),this.b=e*Math.sin(t),this}arg(e){if(void 0===e)return Math.atan2(this.b,this.a);let t=this.mag();return this.a=t*Math.cos(e),this.b=t*Math.sin(e),this}conjugate(){return new t(this.a,-this.b)}reciprocal(){let e=this.a/(Math.pow(this.a,2)+Math.pow(this.b,2)),t=this.b/(Math.pow(this.a,2)+Math.pow(this.b,2));return this.a=e,this.b=-t,this}div(e){let r=(e=t.assert(e)).a*e.a+e.b*e.b,n=this.a*e.a+this.b*e.b,i=this.b*e.a-this.a*e.b;return this.a=n/r,this.b=i/r,this}modulo(e){e=t.assert(e);let n=t.div(this,e),i=this.sub(r(n,Math.floor).mult(e));return this.a=i.a,this.b=i.b,this}pow(e){let r,n;if((e=t.assert(e)).equals(0))r=1,n=0;else if(e.equals(1))r=this.a,n=this.b;else if(this.equals(0)&&0===e.b&&e.a>0)0===e.b&&e.a>0?(r=0,n=0):(r=NaN,n=NaN);else{const t=this.mag(),i=this.arg();let s=Math.pow(t,e.a)*Math.exp(-e.b*i),o=e.a*i+e.b*Math.log(t);r=s*Math.cos(o),n=s*Math.sin(o)}return this.a=r,this.b=n,this}equals(e){return e=t.assert(e),this.a===e.a&&this.b===e.b}toString(e,r){if(t.isNaN(this))return"nan";if(0===this.a&&0===this.b)return"0";let n,i="";return n="upper"===r?t=>t.toString(e).toUpperCase():"lower"===r?t=>t.toString(e).toLowerCase():t=>t.toString(e),0!==this.a&&(i+=isFinite(this.a)?n(this.a):"inf"),0!==this.b&&(this.b>=0&&0!==this.a&&(i+="+"),-1===this.b?i+="-":1!==this.b&&(i+=isFinite(this.b)?n(this.b):"inf"),i+=t.imagLetter),i}toLocaleString(e,r){if(t.isNaN(this))return"nan";if(0===this.a&&0===this.b)return"0";let n="";return 0!==this.a&&(n+=isFinite(this.a)?this.a.toLocaleString(e,r):"inf"),0!==this.b&&(this.b>=0&&0!==this.a&&(n+="+"),-1===this.b?n+="-":1!==this.b&&(n+=isFinite(this.b)?this.b.toLocaleString(e,r):"inf"),n+=t.imagLetter),n}toExponential(e){if(t.isNaN(this))return"nan";if(0===this.a&&0===this.b)return"0";let r="";return 0!==this.a&&(r+=isFinite(this.a)?this.a.toExponential(e):"inf"),0!==this.b&&(this.b>=0&&0!==this.a&&(r+="+"),-1===this.b?r+="-":1!==this.b&&(r+=isFinite(this.b)?this.b.toExponential(e):"inf"),r+=t.imagLetter),r}copy(){return new t(this.a,this.b)}static add(e,r){return e=t.assert(e),r=t.assert(r),e.copy().add(r)}static sub(e,r){return e=t.assert(e),r=t.assert(r),e.copy().sub(r)}static mult(e,r){return e=t.assert(e),r=t.assert(r),e.copy().mult(r)}static div(e,r){return e=t.assert(e),r=t.assert(r),e.copy().div(r)}static modulo(e,r){return e=t.assert(e),r=t.assert(r),e.copy().modulo(r)}static pow(e,r){return e=t.assert(e),r=t.assert(r),e.copy().pow(r)}static sin(e){return e=t.assert(e),new t(Math.sin(e.a)*Math.cosh(e.b),Math.cos(e.a)*Math.sinh(e.b))}static sinh(e){return e=t.assert(e),new t(Math.sinh(e.a)*Math.cos(e.b),Math.cosh(e.a)*Math.sin(e.b))}static arcsinh(e){e=t.assert(e);let r=t.add(1,t.mult(e,e));return t.log(t.add(e,t.mult(t.pow(t.abs(r),.5),t.exp(t.div(t.I(),2).mult(r.arg())))))}static arcsin(e){e=t.assert(e);let r=new t(1-Math.pow(e.a,2)+Math.pow(e.b,2),-2*e.a*e.b).pow(.5),n=t.log(new t(-e.b+r.a,e.a+r.b)),i=new t(0,-1);return t.mult(i,n)}static cos(e){return e=t.assert(e),new t(Math.cos(e.a)*Math.cosh(e.b),-1*Math.sin(e.a)*Math.sinh(e.b))}static cosh(e){return e=t.assert(e),new t(Math.cosh(e.a)*Math.cos(e.b),Math.sinh(e.a)*Math.sin(e.b))}static arccos(e){e=t.assert(e);let r=new t(Math.pow(e.a,2)-Math.pow(e.b,2)-1,2*e.a*e.b).pow(.5),n=t.log(new t(e.a+r.a,e.b+r.b)),i=new t(0,-1);return t.mult(i,n)}static arccosh(e){e=t.assert(e);let r=t.sub(t.mult(e,e),1);return t.log(t.add(e,t.mult(t.pow(t.abs(r),.5),t.exp(t.div(t.I(),2).mult(r.arg())))))}static tan(e){return e=t.assert(e),t.div(t.sin(e),t.cos(e))}static tanh(e){return e=t.assert(e),t.add(Math.sinh(2*e.a),new t(0,Math.sin(2*e.b))).div(Math.cosh(2*e.a)+Math.cos(2*e.b))}static arctan(e){e=t.assert(e);const r=t.mult(t.I(),e);return t.mult(t.div(1,new t(0,2)),t.log(t.div(t.add(1,r),t.sub(1,r))))}static arctanh(e){return e=t.assert(e),t.mult(.5,t.log(t.div(t.add(1,e),t.sub(1,e))))}static log(e){return e=t.assert(e),new t(Math.log(e.mag()),e.arg())}static isNaN(e){return e=t.assert(e),isNaN(e.a)||isNaN(e.b)}static isFinite(e){return e=t.assert(e),isFinite(e.a)&&isFinite(e.b)}static abs(e){return(e=t.assert(e)).mag()}static sqrt(e){return e=t.assert(e),t.pow(e,.5)}static cbrt(e){return e=t.assert(e),t.pow(e,1/3)}static ceil(e){return r(e,Math.ceil)}static floor(e){return r(e,Math.floor)}static round(e){return r(e,Math.round)}static roundDp(e,r){const n=Math.pow(10,r);return new t(Math.round(e.a*n)/n,Math.round(e.b*n)/n)}static exp(e){e=t.assert(e);const r=Math.exp(e.a);return new t(r*Math.cos(e.b),r*Math.sin(e.b))}static fromPolar(e,r){return new t(e*Math.cos(r),e*Math.sin(r))}}function r(e,r){return(e=t.assert(e)).a=r(e.a),e.b=r(e.b),e}t.imagLetter="i",t.I=()=>new t(0,1),t.NaN=()=>new t(NaN,NaN),t.assert=function(e){if(e instanceof t)return e;if("number"==typeof e||"boolean"==typeof e)return new t(e,0);if("bigint"==typeof e)return new t(Number(e),0);if("string"==typeof e){let r,n=e.split(/(?=[\-\+])/).map((e=>e.trim())).filter((e=>e.length>0));if(1===n.length)r=new t(+n[0],0);else if(2===n.length&&-1!==n[1].indexOf(t.imagLetter)){let e=n[1].replace(t.imagLetter,"");"-"!==e&&"+"!==e||(e+="1"),r=new t(+n[0],+e)}if(r&&!t.isNaN(r))return r}throw new TypeError(`Expected Complex, got ${typeof e} ${e}`)},t.is=function(e){try{return t.assert(e)}catch(e){return!1}},e.exports=t},185:(e,t,r)=>{const{LCF:n}=r(787);class i{constructor(e,t=!0){if(e instanceof i)this.numerator=e.numerator,this.denominator=e.denominator;else if(null!=e.toString().match(/\//)){let r=e.toString(),i=null;if(r.match(/\s/)&&!isNaN(Number(r[0]))){let e=r.split(/\s/);i=e[0],r=e[1]}let s=r.split("/");if(t){let e=+s[0],t=+s[1],r=n(e,t);this.numerator=e/r,this.denominator=t/r}else this.numerator=+s[0],this.denominator=+s[1];if(null!=i)for(let e=0;e<i;++e)this.numerator+=this.denominator}else if(Array.isArray(e)&&2===e.length)this.numerator=+e[0],this.denominator=+e[1];else{let t=s.ToFraction(e);this.numerator=t[0],this.denominator=t[1]}if(isNaN(this.numerator)||isNaN(this.denominator))throw new Error(`Fraction: invalid fraction "${e}"`);this.denominator<0&&(this.denominator=Math.abs(this.denominator),this.numerator=-this.numerator)}toNumber(){return this.numerator/this.denominator}toString(e=!0){return 1==this.denominator?this.numerator.toString():this.numerator==this.denominator?"1":this.numerator<this.denominator||e?this.numerator+"/"+this.denominator:Math.floor(this.numerator/this.denominator)+" "+this.numerator%this.denominator+"/"+this.denominator}simplify(){let e=n(this.numerator,this.denominator);return this.numerator/=e,this.denominator/=e,this}reciprocal(){let e=this.numerator;return this.numerator=this.denominator,this.denominator=e,this}negativeReciprocal(){return this.reciprocal(),this.numerator=-Number(this.numerator),this.numerator<0&&this.denominator<0&&(this.numerator=Math.abs(this.numerator),this.denominator=Math.abs(this.denominator)),this}copy(){return new i(this.numerator+"/"+this.denominator)}negative(){return this.numerator=-this.numerator,this}isNegative(){return this.numerator<0}abs(){return this.numerator=Math.abs(this.numerator),this}isGreaterThan(e){let t=s.MakeDenominatorsEqual(this,e);return t[0].numerator>t[1].numerator}isEqualTo(e){let t=s.MakeDenominatorsEqual(this,e);return t[0].numerator==t[1].numerator}pow(e){return e=e instanceof i?e.toNumber():+e,new i(s.ToFraction(this.toNumber()**e))}sqrt(){return new i(s.ToFraction(Math.sqrt(this.toNumber())))}}class s{static ToFraction(e){if(e=+e,isNaN(e))throw new Error("ToFraction: non-numerical value provided");if(e==parseInt(e))return[parseInt(e),1];{let t=e.toString().length-2,r=Math.pow(10,t),i=e*r,s=n(i,r);return i/=s,r/=s,[Math.floor(i),Math.floor(r)]}}static MakeDenominatorsEqual(e,t){if(e instanceof i||(e=new i(e)),t instanceof i||(t=new i(t)),e.denominator==t.denominator)return[e,t];let r=e.numerator*t.denominator,n=e.denominator*t.denominator,s=t.numerator*e.denominator;return[new i(r+"/"+n,!1),new i(s+"/"+n,!1)]}static Add(e,t){if(e instanceof i||(e=new i(e)),t instanceof i||(t=new i(t)),e.denominator==t.denominator)return new i(e.numerator+t.numerator+"/"+e.denominator);{let r=e.numerator*t.denominator,n=e.denominator*t.denominator,s=t.numerator*e.denominator;return new i(r+s+"/"+n)}}static Subtract(e,t){if(e instanceof i||(e=new i(e)),t instanceof i||(t=new i(t)),e.denominator==t.denominator)return new i(e.numerator-t.numerator+"/"+e.denominator);{let r=e.numerator*t.denominator,n=e.denominator*t.denominator,s=t.numerator*e.denominator;return new i(r-s+"/"+n)}}static Multiply(e,t){return e instanceof i||(e=new i(e)),t instanceof i||(t=new i(t)),0==e.numerator||0==e.denominator?e:0==t.numerator||0==t.denominator?t:new i(e.numerator*t.numerator+"/"+e.denominator*t.denominator)}static Divide(e,t){return e instanceof i||(e=new i(e)),t instanceof i||(t=new i(t)),(t=t.copy()).reciprocal(),new i(e.numerator*t.numerator+"/"+e.denominator*t.denominator)}}e.exports={Fraction:i,Fractions:s}},197:e=>{e.exports={DBL_EPSILON:2220446049250313e-31,PI:3.141592653589793,TWO_PI:6.283185307179586,E:2.718281828459045,EXPN1:.36787944117144233,OMEGA:.5671432904097838,PHI:1.618033988749895,MACHEP:2220446049250313e-31}},787:(e,t,r)=>{const{sum:n}=r(89),i=r(397),{TWO_PI:s}=r(197),{lambertw_scalar:o}=r(219),{wrightomega_ext:a}=r(44),{zeta2:l}=r(660),c=e=>n(e)/e.length,u=[676.5203681218851,-1259.1392167224028,771.3234287776531,-176.6150291621406,12.507343278686905,-.13857109526572012,9984369578019572e-21,1.5056327351493116e-7],h=(e,t=1e-7)=>{let r;if((e=i.assert(e)).a<.5)r=i.div(Math.PI,i.mult(i.sin(i.mult(Math.PI,e)),h(i.sub(1,e))));else{e=i.sub(e,1);let t=new i(.9999999999998099);for(let r=0;r<u.length;r++)t.add(i.div(u[r],i.add(e,r).add(1)));let n=i.add(e,u.length).sub(.5);r=i.sqrt(2*Math.PI).mult(i.pow(n,i.add(e,.5))).mult(i.exp(i.mult(n,-1))).mult(t)}return r.b<=t?new i(r.a):r},p=[1,.5];e.exports={bernoulli:function e(t){if(void 0!==p[t])return p[t];let r=1,n=h(t+1);for(let i=0;i<t;i++)r-=n/(h(i+1)*h(t-i+1))*(e(i)/(t-i+1));return p[t]=r,r},lambertw:function(e,t=0,r=1e-8){return e=i.assert(e),t=i.assert(t),r=i.assert(r),o(e,t.a,r.a)},zeta:function(e,t){return void 0===t?NaN:l(e,t)},factorialReal:function(e){if(0===e)return 1;if(e<1||Math.floor(e)!==e)throw new Error(`Argument Error: factorial expects a positive integer, got ${e}`);let t=e--;for(;e>1;e--)t*=e;return t},LCF:function(e,t){let r=0;for(;e!==t;)if(e>t?e-=t:t-=e,++r,r>1e7)return 1;return e},primeFactors:function(e){let t=2,r=[];for(;t*t<=e;)e%t?t++:(e=Math.floor(e/t),r.push(t));return e>1&&r.push(e),r},isPrime:function(e){if(1===e||0===e||e%2==0&&Math.abs(e)>2)return!1;const t=Math.floor(Math.sqrt(e));for(let r=3;r<t;r+=2)if(e%r==0)return!1;return!0},generatePrimes:function(e){const t=new Array(e+1).fill(!1);for(let r=2;r*r<=e;r++)if(!t[r])for(let n=r*r;n<=e;n+=r)t[n]=!0;const r=[];for(let n=0;n<=e;n++)n>1&&!t[n]&&r.push(n);return r},random:function(e,t){return void 0===e&&void 0===t?Math.random():void 0===t?Math.random()*e:e+Math.random()*(t-e)},mean:c,PMCC:(e,t)=>{if(e.length!==t.length)throw new Error("Argument Error: input arrays must be same size");const r=e.length,i=n(e),s=n(t),o=n(e.map((e=>e*e))),a=n(t.map((e=>e*e)));return(r*n(e.map(((r,n)=>e[n]*t[n])))-i*s)/Math.sqrt((r*o-i*i)*(r*a-s*s))},variance:e=>{const t=c(e);return n(e.map((e=>Math.pow(e-t,2))))/e.length},gamma:h,factorial:e=>h(i.add(e,1)),stirling:e=>i.mult(i.sqrt(i.mult(s,e)),i.pow(i.div(e,Math.E),e)),nextNearest:function(e,t){if(isNaN(e)||isNaN(t))return NaN;if(!isFinite(e))return e;if(e===t)return e;let r=new ArrayBuffer(8),n=new Float64Array(r),i=new Uint32Array(r);return n[0]=e,0===e?(i[0]=1,i[1]=t<0?1<<31:0):e>0&&e<t||e<0&&e>t?4294967295==i[0]++&&i[1]++:0==i[0]--&&i[1]--,n[0]},wrightomega:function(e){return a(e).w},range:function(e,t,r=1){let n=[];if(e<t)for(let i=e;i<t;i+=r)n.push(i);else for(let i=e;i>t;i-=r)n.push(i);return n}}},219:(e,t,r)=>{const n=r(397),{PI:i,TWO_PI:s,E:o,EXPN1:a,OMEGA:l}=r(197);function c(e,t,r){let i,s,o=e[0],a=e[1],l=2*r.a,c=r.a*r.a+r.b*r.b;for(i=2;i<=t;i++)s=a,a=-c*o+e[i],o=l*o+s;return n.mult(r,o).add(a)}function u(e,t){let r=n.log(e).add(new n(0,s*t));return n.sub(r,n.log(r))}e.exports={lambertw_scalar:function(e,t,r){let h,p,f,d,m,w,g;if(n.isNaN(e))return e;if(e.a===1/0)return n.add(e,new n(0,s*t));if(e.a===-1/0)return n.add(e.mult(-1),s*t+i);if(e.equals(0))return 0===t?e:new n(-1/0);if(e.equals(1)&&0==t)return l;if(p=n.abs(e),f=0===t?n.abs(n.add(e,a))<.3?function(e){return c([-1/3,1,-1],2,n.pow(n.mult(o,e).add(1).mult(2),.5))}(e):-1<e.a&&e.a<1.5&&Math.abs(e.b)<1&&-2.5*Math.abs(e.b)-.2<e.a?function(e){return n.mult(e,n.div(c([12.851063829787234,12.340425531914894,1],2,e),c([32.53191489361702,14.340425531914894,1],2,e)))}(e):u(e,t):-1===t&&p<=a&&0===e.b&&e.a<0?Math.log(-e.a):u(e,t),f.a>=0)for(h=0;h<100;h++){if(d=n.exp(n.mult(f,-1)),w=n.sub(f,n.mult(e,d)),g=n.sub(f,n.div(w,n.add(f,1).sub(n.mult(n.add(f,2),n.div(w,n.mult(2,f).add(2)))))),n.abs(n.sub(g,f))<r*n.abs(g))return g;f=g}else for(h=0;;h++){if(d=n.exp(f),m=n.mult(f,d),w=n.sub(m,e),g=n.sub(f,n.div(w,n.add(m,d).sub(n.mult(n.add(f,2),n.div(w,n.mult(f,2).add(2)))))),n.abs(n.sub(g,f))<r*n.abs(g))return g;f=g}return console.warn("[!] Failed to converge"),new n(NaN,NaN)}}},44:(e,t,r)=>{const n=r(397),{DBL_EPSILON:i}=r(197);e.exports={wrightomega_ext:function(e,t=null){let r,s,o,a,l,c,u,h=1,p=new n(0,1),f=.01,d=e.a,m=e.b,w=m-Math.PI,g=m+Math.PI;if(isNaN(d)||isNaN(m))return{w:n.NaN(),cond:t};if(!isFinite(d)&&d<0&&-Math.PI<m&&m<=Math.PI)return u=Math.abs(m)<=Math.PI/2?new n(0,m>=0?0:-0):new n(-0,m>=0?0:-0),{w:u,cond:t};if(!isFinite(d)||!isFinite(m))return{w:new n(d,m),cond:t};if(-1===e&&Math.abs(m)===Math.PI)return{w:new n(-1,0),cond:t};if(-2<d&&d<=1&&1<m&&m<2*Math.PI)o=n.sqrt(n.add(e,1).sub(new n(0,Math.PI)).mult(2).conjugate()).conjugate(),u=n.add(-1,n.add(p,n.add(1/3,n.add(new n(0,-1/36),n.add(1/270,new n(0,1/4320).mult(o)).mult(o)).mult(o)).mult(o)).mult(o));else if(-2<d&&d<=1&&-2*Math.PI<m&&m<-1)o=n.sqrt(n.add(e,1).add(new n(0,Math.PI)).mult(2).conjugate()).conjugate(),u=n.add(-1,n.add(new n(0,-1),n.add(1/3,n.add(new n(0,1/36),n.sub(1/270,new n(0,1/4320).mult(o)).mult(o)).mult(o)).mult(o)).mult(o));else if(d<=-2&&-Math.PI<m&&m<=Math.PI){if(o=n.exp(e),u=n.add(1,n.add(-1,n.add(1.5,n.add(-8/3,n.mult(125/24,o)).mult(o)).mult(o)).mult(o)).mult(o),u.equals(0))return console.error("WriteOmega: underflow in exponential series"),{w:u,cond:t=n.div(e,n.add(1,u))}}else if(-2<d&&d<=1&&-1<=m&&m<=1||-2<d&&(d-1)*(d-1)+m*m<=Math.PI*Math.PI)o=n.sub(e,1),u=n.add(n.add(.5,n.mult(.5,e)),n.add(1/16,n.add(-1/192,n.add(-1/3072,n.mult(13/61440,o)).mult(o)).mult(o)).mult(o).mult(o));else if(d<=-1.05&&Math.PI<m&&m-Math.PI<=-.75*(d+1)){if(l=n.sub(e,new n(0,Math.PI)),o=n.log(n.mult(l,-1)),u=n.sub(l,o),c=n.div(o,l),u.add(c),c.div(l),u.add(n.mult(c,n.sub(n.mult(.5,o),1))),c.div(l),u.add(n.mult(c,n.sub(n.mult(o,o).div(3),n.mult(3,o).div(2)).add(1))),n.abs(e)>1e50)return{w:u,cond:t=n.div(e,n.add(1,u))}}else if(d<=-1.05&&.75*(d+1)<m+Math.PI&&m+Math.PI<=0){if(l=n.add(e,new n(0,Math.PI)),o=n.log(n.mult(l,-1)),u=n.sub(l,o),c=n.div(o,l),u.add(c),c.div(l),u.add(n.mult(c,n.sub(n.mult(.5,o),1))),c.div(l),u.add(n.mult(c,n.sub(n.mult(o,o).div(3),n.mult(3,o).div(2)).add(1))),n.abs(e)>1e50)return{w:u,cond:t=n.div(e,n.add(1,u))}}else if(o=n.log(e),u=n.sub(e,o),c=n.div(o,e),u.add(c),c.div(e),u.add(n.mult(c,n.mult(.5,o).sub(1))),c.div(e),u.add(n.mult(c,n.mult(o,o).div(3).sub(n.mult(3,o).div(2)).add(1))),n.abs(e)>1e50)return{w:u,cond:t=n.div(e,n.add(1,u))};d<=-.99&&(Math.abs(w)<=f||Math.abs(g)<=f)&&(h=-1,e=Math.abs(w)<=f?n.add(d,new n(0,w)):n.add(d,new n(0,g))),u=n.mult(h,u),s=n.sub(e,n.mult(h,u)).sub(n.log(u)),a=n.mult(h,u).add(1);let v=n.mult(2,a).mult(n.add(a,n.mult(2/3,s)));r=n.div(s,a).mult(n.sub(v,s)).div(n.sub(v,n.mult(2,s))),u.mult(n.add(1,r));let _=n.mult(2,u).mult(u).sub(n.mult(8,u)).sub(1).mult(n.pow(n.abs(s),4)),y=n.mult(i,72).mult(n.pow(n.abs(a),6));if(n.abs(_)>=y){s=n.sub(e,n.mult(h,u)).sub(n.log(u)),a=n.mult(h,u).add(1);let t=n.mult(2,a).mult(n.add(a,n.mult(2/3,s)));r=n.div(s,a).mult(n.sub(t,s)).div(n.sub(t,n.mult(2,s))),u.mult(n.add(1,r))}return u=n.mult(h,u),{w:u,cond:t=n.div(e,n.add(1,u))}}}},660:e=>{const t=[12,-720,30240,-1209600,47900160,-1892437580.3183792,74724249600,-2950130727918.164,116467828143500.67,-4597978722407473,0x284e46fd8153bc0,-0x637355552018c800];e.exports={zeta2:function(e,r){let n,i,s,o,a,l,c;if(1===e)return 1/0;if(e<1)return NaN;if(r<=0){if(r===Math.floor(r))return 1/0;if(e!==Math.floor(e))return NaN}if(r>1e8)return(1/(e-1)+1/(2*r))*Math.pow(r,1-e);for(a=Math.pow(r,-e),i=r,n=0,s=0;n<9||i<=9;)if(n++,i++,s=Math.pow(i,-e),a+=s,Math.abs(s/a)<MACHEP)return a;for(c=i,a+=s*c/(e-1),a-=.5*s,i=1,o=0,n=0;n<12;n++){if(i*=e+o,s/=c,l=i*s/t[n],a+=l,l=Math.abs(l/a),l<MACHEP)return a;o++,i*=e+o,s/=c,o++}return a}}},225:(e,t,r)=>{const{errors:n}=r(365),{types:i,isTypeOverlap:s}=r(880);class o{constructor(e,t,r,s,o="any"){this.rs=e,this.rargs=r,this.args=new Map,this.name=t,this.desc=s??"[no information]",this.returnType=o,this.argMin=0,this.argMax=0;for(let e in r)if(r.hasOwnProperty(e)){let s={};if("string"==typeof r[e]){let t=r[e];"?"===t[0]&&(t=t.substr(1),s.optional=!0),s.pass="val",s.type=t}else s.pass=r[e].pass,s.type=r[e].type,s.optional=!!r[e].optional,s.default=r[e].default,s.type&&"?"===s.type[0]&&(s.optional=!0,s.type=s.type.substr(1)),s.ellipse=!!r[e].ellipse;if(void 0===s.pass&&(s.pass="val"),void 0===s.type&&(s.type="any"),void 0===s.optional&&(s.optional=!1),void 0===s.ellipse&&(s.ellipse=!1),!i.has(s.type))throw new Error(`[${n.TYPE_ERROR}] Type Error: argument '${e}: ${s.type}': invalid type '${s.type}' (function: ${t})`);this.args.set(e,s),s.ellipse?this.argMax=1/0:s.optional?this.argMax++:(this.argMax++,this.argMin++)}}checkArgCount(e,t=0){let r=this.argMin-t,i=this.argMax-t;if(e.length<r)throw new Error(`[${n.ARG_COUNT}] Argument Error: function '${this.name}' expects at least ${r} argument${1==r?"":"s"} {${Array.from(this.args.values()).filter((e=>!(e.optional||e.ellipse))).map((e=>e.type)).join(", ")}}, got ${e.length} {${e.map((e=>`${e.type()}`)).join(", ")}}`);if(e.length>i)throw new Error(`[${n.ARG_COUNT}] Argument Error: function '${this.name}' expects at most ${i} argument${1==i?"":"s"} {${Array.from(this.args.values()).map((e=>e.type)).join(", ")}}, got ${e.length} {${e.map((e=>`${e.type()}`)).join(", ")}}`)}about(){return this.desc}signature(){return`${this.name}(${Array.from(this.args.keys()).map((e=>this.argumentSignature(e))).join(", ")})`}argumentSignature(e){let t=this.args.get(e);return t?`${t.ellipse?"...":""}${t.optional?"?":""}${e}: ${t.pass} ${t.type}`:""}signatureMatch(e){if(e.argMax<this.argMin)return!1;let t=Array.from(this.args),r=Array.from(e.args);for(let e=0;e<t.length;++e)if(t[e][1].pass!==r[e][1].pass||!s(t[e][1].type,r[e][1].type))return!1;return!0}}class a extends o{constructor(e,t,r,n,i="user-defined",s="any"){super(e,t,r,i,s),this.tstr=n}clone(){return new a(this.rs,this.name,this.rargs,this.tstr)}async call(e,t=[]){this.checkArgCount(t),this.rs.pushScope(e.pid),this.rs.defineVar("args",this.rs.generateArray(t),"Array of values passed to function",e.pid);let r=0;for(let[i,s]of this.args){if(void 0===s.pass||"val"===s.pass){let o;if(s.ellipse){let e=[],a=t.length-(this.args.size-r);for(;r<=a;r++){let o=t[r];try{o=o.castTo(s.type)}catch(e){throw new Error(`[${n.CAST_ERROR}] Type Error: while casting '...' argument ${i} from type ${o.type()} to ${s.type} (function ${this.name}):\n${e}`)}try{o=o.__copy__()}catch(e){throw new Error(`[${n.CANT_COPY}] Argument Error: Cannot copy value of type '${o.type()}' ('...' argument '${i}')`)}e.push(o)}o=this.rs.generateArray(e),--r}else{let a=!0;if(s.optional&&void 0===t[r]?s.default?o="function"==typeof s.default.eval?await s.default.eval(e):s.default:(o=this.rs.UNDEFINED,a=!1):o=t[r],a){try{o=o.castTo(s.type)}catch(e){throw new Error(`[${n.CAST_ERROR}] Type Error: while casting argument ${i} from type ${t[r].type()} to ${s.type} (function ${this.name}):\n${e}`)}try{o=o.__copy__()}catch(e){throw new Error(`[${n.CANT_COPY}] Argument Error: Cannot copy value of type '${o.type()}' (argument '${i}')`)}}}this.rs.defineVar(i,o,void 0,e.pid)}else{if("ref"!==s.pass)throw new Error(`Unknown pass-by value '${s.pass}' for '${t[r]}'`);if("function"==typeof t[r].getVar){let n=t[r].getVar();this.rs.defineVar(i,n,void 0,e.pid).refFor=n}else{if(!(t[r].value instanceof Map))throw new Error(`[${n.BAD_ARG}] Argument Error: Invalid pass-by-reference: type ${t[r]?.type()} ${t[r]}`);this.rs.defineVar(i,void 0,void 0,e.pid),this.rs.setVarObj(i,t[r],void 0,e.pid)}}r++}let i=await this.tstr.eval(e);return i=i.castTo(this.returnType),this.rs.popScope(e.pid),i}}class l extends o{constructor(e,t,r,n,i="[built-in function]"){super(e,t,r,i),this.fn=n}clone(){return new l(this.rs,this.name,this.rargs,this.fn,this.desc)}async call(e,t=[]){this.checkArgCount(t);const r={};let n=0;return this.args.forEach(((e,i)=>{e.ellipse?(r[i]=this.rs.generateArray(t.slice(n)),n+=r[i].length):(r[i]=t[n],n++)})),await this.fn(r,e)}}e.exports={RunspaceFunction:o,RunspaceBuiltinFunction:l,RunspaceUserFunction:a}},47:(e,t,r)=>{const n=r(158),i=r(215),{tokenify:s}=r(543),{createEvalObj:o}=r(89),{primitiveToValueClass:a,MapValue:l,Value:c,FunctionRefValue:u,UndefinedValue:h,ArrayValue:p,BoolValue:f}=r(444),{RunspaceFunction:d}=r(225),{Block:m}=r(317),{errors:w}=r(365);class g{constructor(e={}){this._procs=new Map,this._cpid=0,this._globals=new Map,e.version=g.VERSION,e.name=g.LANG_NAME,e.time=Date.now();const t=new l(this);Object.entries(e).forEach((([e,r])=>t.value.set(e,a(this,r)))),this.defineVar("headers",t,"Config headers of current runspace [readonly]",void 0),this.opts=t,this.root="",this.stdin=n.stdin,this.stdout=n.stdout,this.onLineHandler=void 0,this.onDataHandler=void 0,this.defineVar("_isMain",!0,"Are we currently in a MAIN script (i.e. not an import) ?")}get UNDEFINED(){return new h(this)}get TRUE(){return new f(this,!0)}get FALSE(){return new f(this,!1)}generateArray(e=[]){return new p(this,e)}defineVar(e,t,r,n){let s;if(void 0===t&&(t=new h(this)),s=t instanceof c||t instanceof d?new i(e,t,r):t instanceof i?t.copy():new i(e,a(this,t),r),void 0===n)this._globals.set(e,s);else{if(!this._procs.has(n))throw new Error(`[${w.NAME}] Name Error: no process with PID=${n} (whilst defining ${e})`);const t=this._procs.get(n).vars;t[t.length-1].set(e,s)}return s}setVar(e,t,r,n){if(void 0===n){if(this._globals.has(e)){const r=this._globals.get(e);return r.value=t,r}}else{if(!this._procs.has(n))throw new Error(`[${w.NAME}] Name Error: no process with PID=${n} (whilst setting ${e})`);const i=this._procs.get(n).vars;void 0===r&&(r=i.length-1);for(let n=r;n>=0;n--)if(i[n].has(e)){const r=i[n].get(e);return r.value=t,r}}return!1}setVarObj(e,t,r,n){if(void 0===n){if(this._globals.has(e))return this._globals.set(e,t),t}else{const i=this._procs.get(n).vars;void 0===r&&(r=i.length-1);for(let n=r;n>=0;n--)if(i[n].has(e))return i[n].set(e,t),t}return!1}setGlobalVar(e,t,r){const n=void 0===r?this._globals.get(e):this._procs.get(r).vars[0].get(e);return n.value=t,n}getVar(e,t){if(void 0!==t){if(!this._procs.has(t))throw new Error(`[${w.NAME}] Name Error: no process with PID=${t} (whilst getting ${e})`);const r=this._procs.get(t).vars;for(let t=r.length-1;t>=0;t--)if(r[t].has(e))return r[t].get(e)}return this._globals.get(e)}deleteVar(e,t){if(void 0===t){if(this._globals.has(e))return this._globals.delete(e),!0}else{const r=this._procs.get(t).vars;for(let t=r.length-1;t>=0;t--)if(r[t].has(e))return r[t].delete(e),!0}return!1}pushScope(e=0){this._procs.get(e).vars.push(new Map)}popScope(e=0){this._procs.has(e)&&this._procs.get(e).vars.pop()}defineFunc(e,t){return this.defineVar(e.name,new u(this,e),void 0,t)}create_process(){let e=this._cpid++;return this._procs.set(e,{pid:e,dieonerr:!0,state:0,stateValue:void 0,vars:[new Map],parent:null,children:[],imported_files:[],import_stack:[this.root],blocks:new Map,elhandled:null}),this.defineVar("ans",this.UNDEFINED,"Store result of last execution",e),e}process_adopt(e,t){let r=this._procs.get(e),n=this._procs.get(t);if(void 0===r)throw new Error(`[${w.NAME}] Name Error: no process with PID=${e}`);if(void 0===n)throw new Error(`[${w.NAME}] Name Error: no process with PID=${t}`);if(null!==n.parent)return!1;if(-1===r.children.indexOf(t)){r.children.push(t),n.parent=e;let i=new Map;for(let e=r.vars.length-1;e>=0;e--)for(let[t,n]of r.vars[e])i.set(t,n.deepCopy());0===n.vars.length?n.vars.push(i):n.vars[0]=new Map([...i,...n.vars[0]])}return!0}process_unadopt(e,t){let r=this._procs.get(e),n=this._procs.get(t);if(void 0===r)throw new Error(`[${w.NAME}] Name Error: no process with PID=${e}`);if(void 0===n)throw new Error(`[${w.NAME}] Name Error: no process with PID=${t}`);if(n.parent!==e)return!1;let i=r.children.indexOf(t);return-1!==i&&r.children.splice(i,1),n.parent=null,!0}get_process(e){return this._procs.get(e)}destroy_process(e){let t=this._procs.get(e);for(let e of t.children)this.destroy_process(e);return this._procs.delete(e)}terminate_process(e,t=0,r=!1){const n=this._procs.get(e);if(!n||!r&&0!==n.children.length)return!1;let i=!0;for(let e=n.children.length-1;e>=0;--e){let t=this.terminate_process(n.children[e],r);t&&n.children.splice(e,1),i=i&&t}return i&&(n.stateValue?.promise?.reject?.(),n.state=3,n.stateValue=t),i}async exec(e,t,r=!1){if(!this._procs.has(e))throw new Error(`FATAL: cannot execute code in an unexistant process (PID=${e})`);const n=this._procs.get(e);if(0!==n.state&&1!==n.state)throw new Error(`FATAL: cannot execute code on process PID=${e} as it is not dormant (STATE=${n.state})`);try{n.elhandled=null,n.state=1;let i,a={},l=Date.now();n.stateValue={started:l};let c=s(this,t,r);const u=new m(this,c,c[0]?.[0]?.pos??NaN,e,void 0);u.prepare();let h=o(null,null,e);a.parse=Date.now()-n.stateValue.started,l=Date.now();for(let[e,t]of n.blocks)await t.preeval(h);n.stateValue.promise=u.eval(h),i=await n.stateValue.promise,a.exec=Date.now()-l,i=i?i.castTo("any"):this.UNDEFINED,a.ret=i,a.status=h.action,a.statusValue=h.actionValue,1===n.state&&(n.state=0,n.stateValue=a)}catch(t){const r=new Error(`Process ${e} in '${n.imported_files[n.imported_files.length-1]}':\n${t}`);n.state=2,n.stateValue=r}}process_isfinished(e){let t=this._procs.get(e);if(1===t.state)return!1;{if(0===t.children.length)return!0;let e=!0;for(let r=0;r<t.children.length;++r)e=e&&this.process_isfinished(t.children[r]);return e&&(t.elhandled=null),e}}}g.LANG_NAME="TriflicScript",g.VERSION=1.152,e.exports=g},215:e=>{class t{constructor(e,t,r){this.name=e,this.value=t,this.desc=r??"[no information]",this.refFor=void 0}castTo(e){return this.value.castTo(e)}toPrimitive(e){return this.value.toPrimitive(e)}copy(){return new t(this.name,this.value,this.desc)}deepCopy(){return new t(this.name,this.value.__copy__(),this.desc)}}e.exports=t},89:(e,t,r)=>{const n=r(397),{errors:i}=r(365),s={Reset:"[0m",Bright:"[1m",Dim:"[2m",Underscore:"[4m",Blink:"[5m",Reverse:"[7m",Hidden:"[8m",FgBlack:"[30m",FgRed:"[31m",FgGreen:"[32m",FgYellow:"[33m",FgBlue:"[34m",FgMagenta:"[35m",FgCyan:"[36m",FgWhite:"[37m",BgBlack:"[40m",BgRed:"[41m",BgGreen:"[42m",BgYellow:"[43m",BgBlue:"[44m",BgMagenta:"[45m",BgCyan:"[46m",BgWhite:"[47m"},o=/\s/;function a(e,t){const r=e===t;if(r)return r;let n;try{n=e.castTo("any").__eq__(t)}catch(e){return!1}return n&&n.toPrimitive("bool")}function l(e,t){for(let r=0;r<t.length;r++)if(a(e,t[r]))return r;return-1}const c=["uint8","int8","uint16","int16","uint32","int32","uint64","int64","float32","float64"],u=["getUint8","getInt8","getUint16","getInt16","getUint32","getInt32","getBigUint64","getBigInt64","getFloat32","getFloat64"],h=["setUint8","setInt8","setUint16","setInt16","setUint32","setInt32","setBigUint64","setBigInt64","setFloat32","setFloat64"];e.exports={print:function(...e){console.log(...e)},consoleColours:s,peek:(e,t=1)=>e[e.length-t],isDigit:e=>e>="0"&&e<="9",isWhitespace:e=>o.test(e),prefixLines:function(e,t){return e.split("\n").map((e=>t+e)).join("\n")},getArgvBool:function(e,t,r=!0){return void 0===e[t]?r:"false"!==e[t]&&"0"!==e[t]&&!!e[t]},assertReal:function(...e){for(let t of e)if(t=n.assert(t),!t.isReal())throw new Error(`Real number expected, got ${t}`)},createEnum:function(e){const t={};for(let r in e)e.hasOwnProperty(r)&&(t[r]=e[r],t[e[r]]=r);return t},str:e=>{try{return e.toString()}catch(t){return String(e)}},bool:e=>"false"!==e&&"0"!==e&&!!e,createTokenStringParseObj:(e,t,r,n,i=[],s=!0)=>({rs:e,string:t,pos:r,depth:n,lines:[],comment:"",terminateOn:i,allowMultiline:s}),createEvalObj:(e,t,r)=>({action:0,actionValue:void 0,blockID:e,lineID:t,pid:r}),propagateEvalObj:(e,t)=>{t.action=e.action,t.actionValue=e.actionValue},arraysEqual:function(e,t){let r=Math.max(e.length,t.length);for(let n=0;n<r;n++)if(e[n]!==t[n])return!1;return!0},sort:e=>[...e].sort(((e,t)=>e-t)),sum:e=>e.reduce(((e,t)=>e.add(t)),new n(0)),equal:a,findIndex:l,removeDuplicates:function(e){let t=[];for(let r=0;r<e.length;r++){let n=!1;for(let i=0;i<t.length;i++)if(a(e[r],t[i])){n=!0;break}n||t.push(e[r])}return t},intersect:(e,t)=>e.filter((e=>-1!==l(e,t))),arrDifference:(e,t)=>e.filter((e=>-1===l(e,t))),arrRepeat:function(e,t){if(t<1)return[];const r=[];for(let n=0;n<t;n++)r.push(...e);return r},printError:function(e,t){e.toString().split("\n").forEach((e=>t(`${s.Bright}${s.FgRed}[!] ${s.Reset}${e}\n`)))},printWarn:function(e,t){e.toString().split("\n").forEach((e=>t(`${s.Bright}${s.FgYellow}[!] ${s.Reset}${e}\n`)))},throwMatchingBracketError:function(e,t,r){throw new Error(`[${i.UNMATCHED_BRACKET}] Syntax Error: unexpected bracket token '${e}' at position ${r}; no matching '${t}' found.`)},expectedSyntaxError:function(e,t){throw new Error(`[${i.SYNTAX}] Syntax Error: expected ${e} but got ${t} at position ${t.pos}`)},sortObjectByLongestKey:function(e){let t={};return Object.keys(e).sort(((e,t)=>e.length>t.length?-1:1)).forEach((r=>t[r]=e[r])),t},decodeEscapeSequence:function(e,t){let r;switch(e[t]){case"b":r=String.fromCharCode(8),t++;break;case"n":r=String.fromCharCode(10),t++;break;case"r":r=String.fromCharCode(13),t++;break;case"t":r=String.fromCharCode(9),t++;break;case"v":r=String.fromCharCode(11),t++;break;case"0":r=String.fromCharCode(0),t++;break;case"s":r=String.fromCharCode(32),t++;break;case"x":{t++;let n="";for(;e[t]&&/[0-9A-Fa-f]/.test(e[t]);)n+=e[t],t++;if(0===n.length)throw new Error(`[${i.SYNTAX}] Syntax Error: Invalid hexadecimal escape sequence. Expected hexadecimal character, got '${e[t]}'`);r=String.fromCharCode(parseInt(n,16));break}case"o":{t++;let n="";for(;e[t]&&/[0-7]/.test(e[t]);)n+=e[t],t++;if(0===n.length)throw new Error(`[${i.SYNTAX}] Syntax Error: Invalid octal escape sequence. Expected octal character, got '${e[t]}'`);r=String.fromCharCode(parseInt(n,8));break}case"d":{t++;let n="";for(;e[t]&&/[0-9]/.test(e[t]);)n+=e[t],t++;if(0===n.length)throw new Error(`[${i.SYNTAX}] Syntax Error: Invalid decimal escape sequence. Expected decimal character, got '${e[t]}'`);r=String.fromCharCode(parseInt(n,10));break}default:r=e[t++]}return{char:r,pos:t}},toBinary:function(e,t="float64"){let r=c.indexOf(t),n=new DataView(new ArrayBuffer(8));"uint64"!==t&&"int64"!==t||(e=BigInt(parseInt(e))),n[h[r]](0,e,!0);let i="";for(let e=n.byteLength-1;e>=0;e--)i+=n.getUint8(e).toString(2).toString(2).padStart(8,"0");for(;"00000000"===i.substr(0,8);)i=i.substr(8);return i},fromBinary:function(e,t="float64"){e=e.padStart(64,"0");let r=c.indexOf(t),n=new DataView(new ArrayBuffer(8));for(let t=0,r=7;r>=0;t+=8,r--){let i=e.substr(t,8);n.setUint8(r,parseInt(i,2))}return n[u[r]](0,!0)},numberTypes:c,toJson:function(e){if("string"==typeof e)return e;const t=()=>new Error(`[${i.TYPE_ERROR}] Type Error: Cannot convert type ${e.type()} to JSON`);let r;try{r=e.__toJson__()}catch(e){throw t()}if(null==r)throw t();return r},int_to_base:function(e,t){let r="";if(t<2)return r;for(;e>.1;){let n=e%t;e/=t;let i=n+(n>9?55:48);r+=String.fromCharCode(i)}return r.split("").reverse().join("")},base_to_int:function(e,t){let r=0,n=1===e.length?1:Math.pow(t,e.length-1),i=0;for(;i<e.length;){let s=e[i].charCodeAt(0);r+=(s-(s<=57?48:55))*n,n/=t,i++}return r},returnTypedArray:function(e,t){switch(e){case"uint8":return new Uint8Array(t);case"int8":return new Int8Array(t);case"uint16":return new Uint16Array(t);case"int16":return new Int16Array(t);case"uint32":return new Uint32Array(t);case"int32":return new Int32Array(t);case"uint64":return new BigUint64Array(t);case"int64":return new BigInt64Array(t);case"float32":return new Float32Array(t);case"float64":return new Float64Array(t)}}}},158:e=>{var t,r,n=e.exports={};function i(){throw new Error("setTimeout has not been defined")}function s(){throw new Error("clearTimeout has not been defined")}function o(e){if(t===setTimeout)return setTimeout(e,0);if((t===i||!t)&&setTimeout)return t=setTimeout,setTimeout(e,0);try{return t(e,0)}catch(r){try{return t.call(null,e,0)}catch(r){return t.call(this,e,0)}}}!function(){try{t="function"==typeof setTimeout?setTimeout:i}catch(e){t=i}try{r="function"==typeof clearTimeout?clearTimeout:s}catch(e){r=s}}();var a,l=[],c=!1,u=-1;function h(){c&&a&&(c=!1,a.length?l=a.concat(l):u=-1,l.length&&p())}function p(){if(!c){var e=o(h);c=!0;for(var t=l.length;t;){for(a=l,l=[];++u<t;)a&&a[u].run();u=-1,t=l.length}a=null,c=!1,function(e){if(r===clearTimeout)return clearTimeout(e);if((r===s||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(e);try{r(e)}catch(t){try{return r.call(null,e)}catch(t){return r.call(this,e)}}}(e)}}function f(e,t){this.fun=e,this.array=t}function d(){}n.nextTick=function(e){var t=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)t[r-1]=arguments[r];l.push(new f(e,t)),1!==l.length||c||o(p)},f.prototype.run=function(){this.fun.apply(null,this.array)},n.title="browser",n.browser=!0,n.env={},n.argv=[],n.version="",n.versions={},n.on=d,n.addListener=d,n.once=d,n.off=d,n.removeListener=d,n.removeAllListeners=d,n.emit=d,n.prependListener=d,n.prependOnceListener=d,n.listeners=function(e){return[]},n.binding=function(e){throw new Error("process.binding is not supported")},n.cwd=function(){return"/"},n.chdir=function(e){throw new Error("process.chdir is not supported")},n.umask=function(){return 0}}},t={};function r(n){var i=t[n];if(void 0!==i)return i.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}r.d=(e,t)=>{for(var n in t)r.o(t,n)&&!r.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},r.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{"use strict";const e=r(47),{define:t,defineVars:n,defineFuncs:i}=r(328),s=r(206),{StringValue:o}=r(444),{RunspaceBuiltinFunction:a}=r(225);window.addEventListener("load",(async()=>{document.title=`${e.LANG_NAME} v${e.VERSION}`,document.body.insertAdjacentHTML("beforeend","<h2>STDIN</h2>");const r=document.createElement("textarea");r.classList.add("stdin"),r.id="stdin",document.body.appendChild(r),document.body.insertAdjacentHTML("beforeend","<br>");const l=document.createElement("button");l.innerText="Execute",document.body.appendChild(l);const c=document.createElement("input");c.type="file",c.addEventListener("change",(async()=>{const e=c.files[0];if(e){const t=await async function(e,t){return new Promise((t=>{const r=new FileReader;r.onload=()=>{t(r.result)},r.readAsText(e,undefined)}))}(e);p.value+=f.prompt+`[file: ${e.name}] \n`,await _(t)}}));const u=document.createElement("button");u.innerText="Upload File",u.addEventListener("click",(()=>c.click())),document.body.appendChild(u);let h=document.createElement("button");h.innerText="Clear",h.addEventListener("click",(()=>r.value="")),document.body.appendChild(h),document.body.insertAdjacentHTML("beforeend","<h2>STDOUT</h2>");const p=document.createElement("textarea");p.classList.add("stdout"),p.id="stdout",p.setAttribute("readonly","readonly"),document.body.appendChild(p),document.body.insertAdjacentHTML("beforeend","<br>"),h=document.createElement("button"),h.innerText="Clear",h.addEventListener("click",(()=>p.value="")),document.body.appendChild(h),document.body.insertAdjacentHTML("beforeend","<hr>");const f=s();f.app="WEB",f.file=window.location.hostname;const d=new e(f);t(d),n(d),i(d);const m=d.create_process(),w=d.get_process(m);w.persistent=!0,w.imported_files.push("<textarea>");const g=document.createElement("input");function v(...e){p.value+=e.join(" "),p.scrollTop=p.scrollHeight}async function _(e){await d.exec(m,e),0===w.state&&(w.stateValue.status<0?(v("Process exited with code "+w.stateValue.statusValue+"\n"),d.terminate_process(m,0,!0)):(v(w.stateValue.ret.toString()+"\n"),f.timeExecution&&v(`** Took ${time} ms (${w.stateValue.parse} ms parsing, ${w.stateValue.exec} ms execution)\n`)))}async function y(){r.value.length>0&&(p.value+=f.prompt+r.value+"\n",await _(r.value),r.value="")}g.type="checkbox",g.checked=f.timeExecution,document.body.appendChild(g),g.addEventListener("click",(()=>f.timeExecution=!f.timeExecution)),document.body.insertAdjacentHTML("beforeend","Time execution"),d.defineVar("argv",d.generateArray(),"Arguments provided to the program"),d.defineFunc(new a(d,"exit",{c:"?real_int"},(({c:e})=>(alert(`>> EXITING WITH CODE ${e?e.toString():0}`),window.location.reload(),e)),"Exit the current session")),d.defineFunc(new a(d,"print",{o:"any"},(({o:e})=>(v(e.toString()),d.UNDEFINED)),"Prints object to stdout")),d.defineFunc(new a(d,"println",{o:"?any"},(({o:e})=>(v((e?e.toString():"")+"\n"),d.UNDEFINED)),"prints object to stdout followed by a newline")),d.defineFunc(new a(d,"input",{prompt_:"?string",default_:"?string"},(async({prompt_:e,default_:t})=>{const r=prompt(e,t)??d.UNDEFINED;return new o(d,r)}),"writes <prompt> and waits for input. Resumes execution flow and returnes inputted data when <Enter> is pressed")),d.defineFunc(new a(d,"clear",{},(()=>(p.value="",d.UNDEFINED)),"Clears stdout")),l.addEventListener("click",(()=>y())),document.body.addEventListener("keydown",(async e=>{e.ctrlKey&&"Enter"===e.key&&(await y(),r.focus())})),await function(e){return new Promise((t=>{const r=()=>{for(let[t,r]of e._procs)3===r.state||0===r.state&&r.stateValue&&!r.persistent?e.destroy_process(t):2===r.state&&(v(r.stateValue.toString()+"\n"),e.terminate_process(t,1,!0));e._procs.size>0?setTimeout(r,1):t(!0)};r()}))}(d)}))})()})();